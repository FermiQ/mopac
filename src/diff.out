Only in ../../MOPAC/src/: CMakeLists.txt
diff ./GetDateStamp.F90 ../../MOPAC/src/GetDateStamp.F90
3,4c3,4
<    date_time = "Thu May 16 16:55:54 2019"
<    version = "19.136"
---
>    date_time = "Thu Jun 28 09:31:13 2018"
>    version = "18.179"
diff ./H_bond_correction_PM6_DH_type.F90 ../../MOPAC/src/H_bond_correction_PM6_DH_type.F90
48c48
<       max_h_bonds = max_h_bonds*125
---
>       max_h_bonds = max_h_bonds*110
181c181
<   hbs1_ok = .false.
---
>  
diff ./H_bond_correction_bits.F90 ../../MOPAC/src/H_bond_correction_bits.F90
152,153c152,153
<                     call mopend("The default array size for hydrogen bonds is too small")
<                     write(iw,'(9x,a,i6,a,i6)')" Array size:", max_h_bonds,", estimated size needed:", &
---
>                     write(iw,'(a)')" The default array size for hydrogen bonds is too small"
>                     write(iw,'(a,i6,a,i6)')" Array size:", max_h_bonds,", estimated size needed:", &
155,161c155,162
<                 !    if (index(keywrd, "PM6-DH+") /= 0 ) then
<                 !      write(iw,'(a)')" If possible, use PM6-DH+=(text)"
<                 !      call web_message(iw,"PM6_DH_plus.html")
<                 !    else
<                 !      write(iw,'(a)')" If possible, use PM6-DH2=(text)"
<                 !      call web_message(iw,"PM6_DH2.html")
<                 !    end if
---
>                     if (index(keywrd, "PM6-DH+") /= 0 ) then
>                       write(iw,'(a)')" If possible, use PM6-DH+=(text)"
>                       call web_message(iw,"PM6_DH_plus.html")
>                     else
>                       write(iw,'(a)')" If possible, use PM6-DH2=(text)"
>                       call web_message(iw,"PM6_DH2.html")
>                     end if
>                     call mopend("The default array size for hydrogen bonds is too small")
175d175
<     return
Only in .: MOPAC for Windows.F90
Only in .: MOZYME_eigs.F90
Only in .: Password for export.F90
diff ./Password.F90 ../../MOPAC/src/Password.F90
2,654c2
<   use molkst_C, only: ijulian, line, academic, site_no, verson
<   use reada_I
<   use chanel_C, only : iw0
<   implicit none
<   integer :: date_of_creation
<   integer :: i, j, jj, k, pass, p_new = 0, screen, ii(2)
<   integer, parameter :: n_ac = 56, n_co = 77
<   character :: mopac_pw*300, julian*8, academic_text(n_ac)*90, commercial_text(n_co)*90
<   integer, external :: getenvqq
<   logical :: exists, new, site_ok, opend
<   integer, external :: iargc 
<   character (len=8), external :: jdate
<   data academic_text &
<   
<   /"Academic End User Software License Agreement", &
<   "Important:  ", &
<   "This License Agreement (""Agreement"") is a legal agreement between you, ", &
<   "the end user (either an individual or an entity), and Stewart Computational ", &
<   "Chemistry (""SCC"").  By typing the word ""Yes"" below, you signify that you ", &
<   "have read the SCC License Agreement and accept its terms.  If you do not agree ", & 
<   "to the Agreement's terms, please delete all copies of this Software.", &
<   "Grant of License. ", & 
<   "SCC grants, and you hereby accept, a non-exclusive license to install and use", &
<   "the enclosed software product (""Software"") in accordance with the", &
<   "terms of this Agreement.  This licensed copy of the Software may only be used ", &
<   "at a single site. You may not: (a) electronically transfer the Software from", &
<   "one site to another, (b) distribute copies of the Software to other sites, or ", &
<   "(c) modify or translate the Software without the prior written consent of SCC.  ", &
<   "The Software may be placed on a file or disk server connected to a network. ", &
<   "You may make only those copies of the Software which are necessary ", &
<   "to install and use it as permitted by this Agreement, or are for purposes of ", &
<   "backup and archival records; all copies shall bear SCC's copyright and ", &
<   "proprietary notices.  You may not make copies of any accompanying materials ", &
<   "without prior, written notice from SCC.", &
<   " ", &
<   "Ownership.  ", &
<   "The Software is and at all times shall remain the sole property of SCC or ", &
<   "its Licensors.  This ownership is protected by the copyright laws of the ", &
<   "United States and by international treaty provisions. You may not modify, ", &
<   "decompile, reverse engineer, or disassemble the Software.", &
<   " ", &
<   "Assignment Restrictions.  ", &
<   "You shall not rent, lease, or otherwise sublet the Software or any part thereof.  ", &
<   " ", &
<   "No Warranty.", &
<   "SCC offers no warranties whatsoever.", &
<   " ", &
<   "SCC's Liability.  ", &
<   "In no event shall SCC or its agents be liable for any indirect, special, or", &
<   "consequential damages, such as, but not limited to, loss of anticipated profits", &
<   "or other economic loss in connection with or arising out of the use of the ", &
<   "software by you or the services provided for in this Agreement, even if SCC ", &
<   "has been advised of the possibility of such damages.  ", &
<   " ", &
<   "No Other Warranties.  ", &
<   "SCC and its agents disclaims other implied warranties, including, but not  ", &
<   "limited to,implied warranties of merchantability or fitness for any purpose,  ", &
<   "and implied warrantiesarising by usage of trade, course of dealing, or   ", &
<   "course of performance. ", &
<   " ", &
<   "Governing Law.  ", &
<   "This Agreement shall be construed according to the Laws of the State of Colorado.", &
<   " Colorado.", &
<   " ", &
<   "----------------------------------------------------------------------------------", &
<   "Stewart Computational Chemistry", &
<   "15210 Paddington Circle, Colorado Springs, Colorado  80921-2512, USA.", &
<   "URL: http://openmopac.net/                          mail: MrMOPAC@ATT.net", &
<   "----------------------------------------------------------------------------------", &
<   "++++" /
<   data commercial_text /&
< 'Commercial End User Software License Agreement ', &
< ' ', &
< 'Important:  ', &
< 'This License Agreement ("Agreement") is a legal agreement between you, the end ', &
< 'user (either an individual or an entity), and Stewart Computational Chemistry ("SCC").  ', &
< 'By typing "Yes" below, you signify that you have read the SCC License Agreement ', &
< 'and accept its terms.  If you do not agree to the Agreement''s terms, please ', &
< 'delete all copies of this Software.', &
< ' ', &
< 'Grant of License.  ', &
< 'SCC grants, and you hereby accept, a non-exclusive license to install and use ', &
< 'one copy of the enclosed software product ("Software") in accordance with the ', &
< 'terms of this Agreement.  This licensed copy of the Software may only be used ', &
< 'on a single computer. You may not: (a) electronically transfer the Software from ', &
< 'one computer to another, (b) distribute copies of the Software to others, or ', &
< '(c) modify or translate the Software without the prior written consent of SCC.  ', &
< 'The Software may be placed on a file or disk server connected to a network, ', &
< 'provided that a license has been purchased or legally acquired and registered ', &
< 'for every computer with access to that server or some license management software ', &
< 'is present and in use to allow only licensed users to access the Software.  ', &
< 'You may make only those copies of the Software which are necessary to install ', &
< 'and use it as permitted by this Agreement, or are for purposes of backup and ', &
< 'archival records; all copies shall bear SCC''s copyright and proprietary notices.  ', &
< 'You may not make copies of any accompanying materials without prior, written ', &
< 'notice from SCC.', &
< ' ', &
< 'Ownership.  ', &
< 'The Software is and at all times shall remain the sole property of SCC or its ', &
< 'Licensors.  This ownership is protected by the copyright laws of the United States ', &
< 'and by international treaty provisions.  Upon expiration or termination of this ', &
< 'Agreement, you shall promptly delete all copies of the Software and accompanying ', &
< 'materials.  You may not modify, decompile, reverse engineer, or disassemble the ', &
< 'Software.', &
< ' ', &
< 'Assignment Restrictions.  ', &
< 'You shall not rent, lease, or otherwise sublet the Software or any part thereof.  ', &
< 'You may transfer on a permanent basis the rights granted under this license provided ', &
< 'you transfer this Agreement and all copies of the Software, including prior versions, ', &
< 'and all accompanying materials (included in the product download).  The recipient ', &
< 'must agree to the terms of this Agreement in full and register this transfer with SCC.', &
< ' ', &
< 'SCC Limited Warranty.', &
< 'SCC''s sole warranty with respect to the Software is that it shall be free of errors ', &
< 'in program logic or documentation attributable to SCC and of errors that prevent the ', &
< 'performance of the principal computing functions of the Software.  SCC warrants this ', &
< 'for a period of ninety (90) days from the date of receipt of the Software.', &
< ' ', &
< 'SCC''s Liability.  ', &
< !123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
< 'In no event shall SCC or its agents be liable for any indirect, special, or consequential', &
< 'damages, such as, but not limited to, loss of anticipated profits or other economic loss', &
< 'in connection with or arising out of the use of the software by you or the services ', &
< 'provided for in this Agreement, even if SCC has been advised of the possibility of ', &
< 'such damages.  SCC''s entire liability and your exclusive remedy shall be, at SCC''s ', &
< 'discretion, to return the Software and proof of purchase to SCC for either (a) return ', &
< 'of any license fee, or (b) correction or replacement of Software that does not meet ', &
< 'the terms of this limited warranty.', &
< ' ', &
< 'No Other Warranties.  ', &
< 'SCC and its agents disclaims other implied warranties, including, but not limited to,  ', &
< 'implied warranties of merchantability or fitness for any purpose, and implied warranties ', &
< 'arising by usage of trade, course of dealing, or course of performance.  Some states ', &
< 'do not allow the limitation of the duration or liability of implied warranties, so ', &
< 'the above restrictions might not apply to you.', &
< ' ', &
< 'Governing Law.  ', &
< 'This Agreement shall be construed according to the Laws of the State of Colorado.', &
< ' ', &
< '----------------------------------------------------------------------------------', &
< 'Stewart Computational Chemistry', &
< '15210 Paddington Circle, Colorado Springs, Colorado  80921-2512, USA.', &
< 'URL: http://openmopac.net/                          Email: MrMOPAC@ATT.net', &
< '----------------------------------------------------------------------------------', &
< "*******************************************************************************", &
< "** Cite this work as: MOPAC2016, James J. P. Stewart, Stewart Computational  **", & 
< "** Chemistry, Colorado, USA      web: HTTP://OpenMOPAC.net                   **", &
< "*******************************************************************************", &
< '++++'/
<   if (site_no == 999) then 
<     ijulian = 1000
<     verson(7:7) = "W"
<     return                                   !
<   end if
<   if (iw0 == 0) then
<     screen = 6
<   else
<     screen = 0
<   end if
<   ii(1) = 0
<   ii(2) = screen
<   i = getenvqq("MOPAC_LICENSE",mopac_pw) 
<   if (i /= 0) then
<     i = len_trim(mopac_pw)
<     if (mopac_pw(2:2) ==":" .or. index(mopac_pw, "$") /= 0) then  !  Is a Windows system
<       if (mopac_pw(i:i) /= "\") then !  Add a terminal slash if it is not already present
<         mopac_pw(i + 1:i + 1) ="\"
<       end if
<       verson(7:7) = "W"
<       inquire (directory = trim(mopac_pw), exist = exists)
<       if ( .not. exists) then
<         write(screen,*)" Environmental variable ""MOPAC_LICENSE"" exists, but its value" 
<         write(screen,*)" does not represent a folder on this computer"
<         write(screen,*)" (An attempt was made to detect the folder '"//trim(mopac_pw)//"')"
<         stop
<       end if
<       inquire (file = trim(mopac_pw)//"MOPAC2016.exe", exist = exists)
<       if (exists) then
<         mopac_pw= trim(mopac_pw)//"password for MOPAC2016"
<       else
<         write(screen,*)" Environmental variable ""MOPAC_LICENSE"" exists, but its value"
<         write(screen,*)" does not represent a folder on this computer that contains MOPAC2016.exe"
<         write(screen,"(a)")"(An attempt was made to detect the file '"//trim(mopac_pw)//"MOPAC2016.exe')"
<         stop
<       end if
<     else if (index(mopac_pw, "/") /= 0) then ! It is a Linux system
<       if (mopac_pw(i:i) /= "/") then !  Add a terminal slash if it is not already present
<         mopac_pw(i + 1:i + 1) ="/"
<       end if
<       inquire (file = trim(mopac_pw)//"mopac2016.exe", exist = exists)
<       if (exists) then
<         verson(7:7) = "M"
<       else
<         inquire (file = trim(mopac_pw)//"MOPAC2016.exe", exist = exists)
<         verson(7:7) = "L"
<       end if
<       if (exists) then
<         mopac_pw= trim(mopac_pw)//"password_for_mopac2016"
<       else
<         write(screen,*)" Environmental variable ""MOPAC_LICENSE"" exists, and the directory it points to exists,"
<         write(screen,*)" but the directory does not contain the MOPAC2016 executable"
<         write(screen,*)" (MOPAC_LICENSE points to directory '"//trim(mopac_pw)//"')"
<         stop
<       end if   
<     end if
<   else
< !
< !  Environmental variable not set.  Test for defaults
< !
<     inquire (directory = "C:\", exist = exists)
<     if (exists) then
< !
< ! Platform is Windows
< !  
<       inquire (directory = "C:\program files\", exist = exists)
<       if (exists) then
<         inquire (directory = "C:\program files\mopac", exist = exists)
<         if ( .not. exists) then
<           write(screen,*) 
<           write(screen,*) '  The MOPAC2016.exe file MUST be put in folder C:\Program Files\mopac'
<           write(screen,*) '  unless the Environmental Variable MOPAC_LICENSE is set.'
<           write(screen,*) ' '
<           write(screen,*) '  If a different location is used, set the location in the Environmental Variable "MOPAC_LICENSE".'
<           write(screen,*) '  For example, the Variable: MOPAC_LICENSE could be given the Value: M:\Utility.'
<           call web_message(screen,"password_inaccessible.html")
<           write(screen,*) " Correct this fault before continuing"
<           read(5,"(a)")line
<           stop
<         end if
<         mopac_pw   = 'C:\program files\mopac\password for MOPAC2016'
<       else
< !
< !  The Operating System is WINDOWS, but the folder "program files" does not exist.
< !  So put the password in the root folder, "C:\".
< !
<         mopac_pw   = 'C:\password for MOPAC2016'
<       end if
<       verson(7:7) = "W"
<     else
< !
< ! Check for Linux or Macintosh.  This is a poor test: Macintosh platforms are case-insensitive
< ! and Linux platforms are case-sensitive.  This is used in deciding whether to use "W" or "M".
< ! The test is poor because there is no guarantee that the case sensitivity will always be the same.
< ! but since the only use of the case is in the output, this is not very important.
< !
<       inquire (file = "/opt/mopac/mopac2016.exe", exist = exists)
<       if (exists) then
<         verson(7:7) = "M"
<         mopac_pw = "/opt/mopac/password_for_mopac2016"
<       else
<         inquire (file = "/opt/mopac/MOPAC2016.exe", exist = exists)
<         verson(7:7) = "L"
<         mopac_pw = "/opt/mopac/password_for_mopac2016"
<       end if
<       if (.not. exists) then
< !
< ! Platform is neither Linux nor Macintosh
< !
<         write(screen,'(a)')' The MOPAC executable must be put into a directory named "/opt/mopac"'
<         write(screen,'(a)')' (If it cannot be put there, use environmental variable MOPAC_LICENSE to re-define the directory)'
<         call web_message(screen,"trouble_shooting.html#default location")
<         stop
<       end if
<     end if
<   end if
<   j = 0
<  98 continue
<   j = j + 1
<   inquire (file = trim(mopac_pw), exist = exists)
<   if (.not. exists) then
< !
< ! Password for MOPAC2016 does not exist, so check for Password for MOPAC2012
< !
<     do k = len_trim(mopac_pw), 1, -2
<       if (mopac_pw(k:k) == "/" .or. mopac_pw(k:k) == "\") exit
<     end do
<     i = index(mopac_pw(k:),"MOPAC20") + index(mopac_pw(k:),"mopac20") + 5 + k
<     mopac_pw = mopac_pw(:i)//"12"
<     inquire (file = trim(mopac_pw), exist = exists)
<     if (exists) then
<       write(screen,*)"An old license file for MOPAC2012 was found." 
<       write(screen,*)"An attempt will be made to write a license for MOPAC2016."
<       p_new = 76
<       open(p_new, file = mopac_pw(:i)//"16", form="unformatted", iostat = j)
<       if (j /= 0) then
<         write(screen,'(/,a)')" The attempt to write the license file for MOPAC2016 failed."
<         if (j == 9) then
<           write(screen,*)"Permission to write to the file:", """"//mopac_pw(:i)//"16"" denied"
<           write(screen,*)"For information on setting permissions, see:"
<           write(screen,*)"HTTP://OpenMOPAC.net/Windows_set_permissions.html"
<           write(screen,*)"(Delete this window when it is no longer wanted.)"
<         end if
<         do
<           inquire(unit=0, opened=opend) 
<           if (opend) call sleep(1)
<         end do
<         stop
<       end if
<     else
<       mopac_pw = mopac_pw(:i)//"16"
<     end if
<   end if
<   if (exists .and. j < 3) then    
<     do jj = 1, 3
<       open(unit=7, file=trim(mopac_pw), form="unformatted", iostat = i)
<       if (i == 0) exit
<       call sleep(1)
<     end do
<     if (i /= 0) then
<       write(screen,*) 'Password file "' //trim(mopac_pw) //'" exists, ','but is currently inaccessible'
<       call web_message(screen,"password_inaccessible.html")
<       write(screen,*) " Correct this fault before continuing"
<       read(5,"(a)")line
<       stop
<     end if  
<     read(7, iostat=i)pass, site_no
<     if (i /= 0) then
<       if (i == -1) then
<         close (7, STATUS = "DELETE",iostat=i)        
<         if (i /= 0) then
<           write(line,'(2a)')" Unable to delete corrupt password file in '", trim(mopac_pw)//"'"
<           write(screen,'(//10x,a,/)')trim(line)
<           write(screen,'(10x,a)')" Press 'Enter' to finish"
<           call mopend(trim(line))
<           read(*,*)
<           stop
<         end if
<         goto 98
<       else
<         write(line,'(2a)')" Unable to read password file in '", trim(mopac_pw)//"'"
<       end if
<       write(screen,'(//10x,a,/)')trim(line)
<       write(screen,'(10x,a)')" (To correct this fault, delete the file '"//trim(mopac_pw)//"' and try again.)"
<       call mopend(trim(line))
<       stop
<     end if     
<     new = .false.
<     if  (p_new /= 0) then
<       write(p_new, iostat=i)pass, site_no
<       close (p_new)
<     end if
<   else
< !
< !  "exists" is true only if a password exists in the appropriate place.
< !   
<     new = .true.    
<     line = " "
< !
< !
< !                    Read in the password
< !
< !
< !
<     i = iargc()
<     if (i == 0) then
<     !  i = from_MAC_address()
<       write(screen,'(//10x,a,/)')" MOPAC is a semiempirical quantum chemistry program"
<       write(screen,'(10x,a)')" To install the MOPAC license, use the command"
<       write(screen,'(10x,a)')" 'MOPAC2016.exe <license-key>'"
<       write(screen,'(10x,a)')" e.g., 'MOPAC2016.exe 1234567a1234567'"
<       call web_message(screen,"running_MOPAC.html")
<       write(screen,'(10x,a)')" Press (return) to continue"
<       read(5,*) 
<       stop
<     end if
<     call getarg (1, line)
<     do i = 1, 60 
<       if(line(1:1) == " ")then
<         line = line(2:)
<       else if (index(line,"\") /= 0 .or. index(line,"/") /= 0) then
<         j = index(line,"\")
<         if (j > 0) line = line(j + 1:)
<         j = index(line,"/")
<         if (j > 0) line = line(j + 1:)
<       else
<         exit
<       end if
<     end do
<     pass = nint(reada(line,1)) 
<     if (pass > 99999999 .or. pass < 999999) then
<       do i = 1, 2
<         if (i == 2 .and. ii(i) == 0) exit
<         write(ii(i),'(a)')" The licence key has not been read in,"
<         write(ii(i),'(a)')" instead, an attempt was made to run MOPAC with the file """//trim(line)//"""" 
<         write(ii(i),'(/,a)')" To activate MOPAC, run it using your personal license key."    
<         write(ii(i),'(/,a)')" The command should be of the type ""MOPAC2016.exe 12345678a12345678""" 
<         write(ii(i),'(a)')" or ""MOPAC2016.exe 12345678a12345678.mop"" (this file can be empty)" 
<         write(ii(i),'(/,a)')" (Replace the key ""12345678a12345678"" with the license key you were given.)"
<       end do
<       call sleep(1000)  
<       stop
<     end if
<     i = index(line,"a") + index(line,"A")
<     if (i /= 0) then
<       site_no = nint(reada(line, i))
<       if (site_no > 99999999 .or. site_no < 999999) then
<         write(screen,'(/,a)')" There must be 7 or 8 digits in the second set of numbers in the licence key" 
<          if (screen == 6) then
<         write(0,'(a)')" Licence key: """//trim(line)//""" read in" 
<         write(0,'(a)')" (The licence key must be in the format ""12345678a12345678"")"    
<         write(0,'(/,a)')" There must be 7 or 8 digits in the second set of numbers in the licence key" 
<       end if
<      call sleep (1000)
<         stop
<       end if
<       i = Mod(pass,1523)
<       j = Mod(site_no,1511)
<     end if
<     site_ok = .false.
<     if (i == 0 .and. pass > 0 .and. j == 0 .and. site_no > 0)then
<       if (screen == 6) &
<       write(0,'(/,a)')" Minimize this window so you can see the license agreement." 
< !
< !  This is the Academic license
< !
<       do i = 1, n_ac
<         if (Index(academic_text(i),"++++") /= 0) exit
<         write(screen,"(a)")academic_text(i)(:len_trim(academic_text(i)))
<         if (mod(i,52) == 0) then
<           write(screen,*)" Press (return) to exit"
<           read(5,*) 
<         end if
<       end do
<       site_ok = .true.
<     end if
<     i = Mod(pass,1511)
<     j = Mod(site_no,1523)      
<     if (i == 0 .and. pass > 0 .and. j == 0 .and. site_no > 0)then
<       if (screen == 6) &
<       write(0,'(/,a)')" Minimize this window so you can see the license agreement." 
< !
< !  This is the Commercial license
< !
<       ijulian = ijulian + pass/1523
<       if (ijulian < -59) then
<         write(screen,"(///10x,a)")" This version of MOPAC is now out-of-date"
<         close(7, status="delete")
<         stop
<       end if
<       do i = 1, n_co
<         if (Index(Commercial_text(i),"++++") /= 0) exit
<         write(screen,"(a)")Commercial_text(i)(:len_trim(Commercial_text(i)))
<         if (mod(i,52) == 0) then
<           write(screen,*)" Press (return) to exit"
<           read(5,*) 
<         end if
<       end do
<       site_ok = .true.
<     end if
<     if ( .not. site_ok) then
<       write(screen,"(//,a)")" A password file was supplied, but the eight-digit numerical codes were not"
<       write(screen,"(a)")" recognized.  Check the digits of the numerical codes and try again"
<       write(screen,"(a)")" "
<       write(screen,"(a)")" Reminder: To install the password, run MOPAC with the file name equal to "
<       write(screen,"(a)")" the password.  For example, if the password is 1234567a12345678, then run "
<       write(screen,"(/,a)")" ""MOPAC2016.exe 1234567a12345678"""
<       close(7, status="delete", iostat = i)
<       write(screen,"(//,a)") " Password invalid"
<       open(unit=7, file=trim(mopac_pw), form="unformatted", iostat = i)
<       close(7, status="delete", iostat = i)
<       if (screen == 6) &
<       write(0,'(/,a)')" An error ocurred. Minimize this window so you can see the error message." 
<       call sleep(1000)    
<       stop
<     end if
<     write(screen,"(a,//,a)")"Scroll down to see the next part", &
<       "Are these conditions are acceptable?"
<     do
<       write(screen,"(a)")" Type a ""Yes"" or ""No"" on the following line and press (return) to continue"
<       read(5,"(a)")line
<       call upcase(line,len_trim(line))
<       if (index(line,"ES") /= 0) then
<         exit
<       else if (index(line,"O") /= 0) then
<         write(screen,*)" Please send a message to MrMOPAC@ATT.net giving details", &
<         " why the conditions are unacceptable."
<         close(7, status="delete")
<         stop
<       end if
<     end do
<     open(unit=7, file=trim(mopac_pw), form="unformatted", iostat=i)
<     if (i == 9) then
<       write(screen,'(/)')
<       write(screen,'(a)')" The file: ", " """//trim(mopac_pw)//""""," cannot be created - check permissions"
<       if (verson(7:7) == "W") &
<         write(screen,'(/,a,//)')" For instructions, see: http://openmopac.net/Windows_set_permissions.html"  
<       write(screen,'(/,a)')" (Delete this window when it is no longer wanted.)"
<       do
<         inquire(unit=0, opened=opend) 
<         if (opend) call sleep(1)
<       end do
<       stop     
<     end if
<     write(7, iostat=i)pass, site_no
<     if (i /= 0) then
<       write(screen,'(a)')" Cannot write password to file '"//trim(mopac_pw)//"'"
<       do i = 1,100
<         write(screen,'(a)')' '
<       end do
<       stop
<     end if
<     close(7, status="keep")
<     write(screen,"(//a,////)")"         Password for MOPAC2016 successfully installed. Enjoy!"
<     call sleep(3)
<     stop
<   end if
< !
< !   A valid password is now in the file mopac_pw
< !        
< !  On entry to password, ijulian is set to minus the number of days that have
< !  passed since 1 January 2009
< !
< !  The password should be translate at the number of days since 1 January 2007 
< !  plus the number of days the password is good for.
< !  Academic sites get 366 days
< !  Commercial evaluation sites get 31 days
< !  All other commercial sites get 366 or more days
< !
< !
<   do k = 1, 3
<     open(unit=7, file=trim(mopac_pw), form="unformatted", iostat=i)
<     if (i == 0) exit
<     call sleep(1)
<   end do
<   if (i /= 0) then
<     write(line,'(2a)')" Password file: '"//trim(mopac_pw)//"' exists, but it cannot be opened."
<     write(screen,'(//10x,a,//)')trim(line)
<     call mopend(trim(line))
<     stop
<   end if
<   read(7, iostat=i)pass, site_no
<   if (i < -1 .or. i > 0) then
<     write(line,'(2a)')" Password file: '"//trim(mopac_pw)//"' exists, but it cannot be read."
<     write(screen,'(//10x,a,//)')trim(line)
<     call mopend(trim(line))
<     stop
<   end if
<   call getdatestamp(line, julian)
<   julian(3:) = julian(4:)
< !
< !  Set date_of_creation to the date of creation of the executable
< !
<   date_of_creation = ((ichar(julian(2:2)) - ichar('0'))*365 + &
<                       (ichar(julian(3:3)) - ichar('0'))*100 + &
<                       (ichar(julian(4:4)) - ichar('0'))*10  + &
<                       (ichar(julian(5:5)) - ichar('0')))    + 1096
<   julian = jdate() 
< !
< !  Set ijulian to minus the number of days lapsed since 1-Jan-2009
< !
<   ijulian = - (((ichar(julian(2:2)) - ichar('0'))*365 + &
<                 (ichar(julian(3:3)) - ichar('0'))*100 + &
<                 (ichar(julian(4:4)) - ichar('0'))*10 + &
<                 (ichar(julian(5:5)) - ichar('0'))) + 1096)
< !
< !  CHECK TO SEE IF THE LICENSE IS ACADEMIC
< !
<   i = Mod(pass,1523)
<   j = Mod(site_no,1511)
<   site_ok = .false.
<   if (i == 0 .and. pass > 0 .and. j == 0 .and. site_no > 0)then
< !
< !  Prevent MOPAC running if other specific programs are present
< !
< ! do i = 2009, 2015
< !   write(line,'(a,i4,a)')"C:\Program files\Cambridgesoft\ChemOffice",i,"\Chem3D"
< !   inquire (file=trim(line), exist = exists)
< !   if (exists) exit
< ! end do
< ! if (i < 2016) then
< !   write(screen,"(/10x,a)")" MOPAC requires a commercial license key to work with Chem3D,"
< !   write(screen,"( 10x,a)")" and this key was not found. The free Academic license key "
< !   write(screen,"( 10x,a)")" for stand-alone MOPAC is not valid for Chem3D. "
< !   write(screen,"( 10x,a)")" The commercial license key is available at a discount to "
< !   write(screen,"( 10x,a)")" Academics from: http://cacheresearch.com/mopac.html"
< !   write(screen,"(/10x,a)")" Press press 'enter' to continue in Demo mode only (accepts  "
< !   write(screen,"( 10x,a)")" only molecules with 1-12, 50-60, or 110-120 atoms)."
< !   read(5,*)
< !   ijulian = ijulian + 10000 !  
< !   site_no = -1
< !   return
< ! end if
< !
< !  This is the Academic license.  Set the executable to expire 365 days after the executable is constructed.
< !
< !
< !  ijulian           = -(current number of days since the end of 2006)
< !  date_of_creation  = number of days since the end of 2006 until the executable was made.
< !
<     ijulian = ijulian + date_of_creation + 365 
<     academic = .true.
<     site_no = site_no/1511 - 10000
<     if (ijulian < 0) then
<       write(screen,"(///,10(10x,a,/))") &
<         " Your MOPAC executable, Version: "//verson//", has expired.", &
<         " Please go to web-site: http://openmopac.net/Download_MOPAC_Executable_Step2.html to get a new version of MOPAC.", &
<         " Do NOT request a new license key.  Academic license keys do not include time limits - the limit is in the program.", &
<         " ", &
<         " Press (enter) to continue."
<       ijulian = 0
<       read(5,'(i5)', iostat = i)k
<     end if
<     site_ok = .true.
<   end if
< ! j = from_MAC_address()
< !
< !  CHECK TO SEE IF THE LICENSE IS COMMERCIAL
< !
<   i = Mod(pass,1511)
<   if (j /= i) then
<     j = i
<   end if
<   j = Mod(site_no,1523)
<   if (i == 0 .and. pass > 0 .and. j == 0 .and. site_no > 0)then
< !
< !  This is the commercial license
< !
<     ijulian = ijulian + pass/1511 
<     academic = .false.
<     site_no = site_no/1523 - 10000
<     if (ijulian < 0) then
<       write(screen,"(///,10(10x,a,/))") &
<  " The license for this copy of MOPAC has expired", &
<  " Please go to web-site: HTTP://OpenMOPAC.net for instructions on", &
<  " renewing the license", &
<  " ", &
<  " Press (return) to continue."
<       read(5,'(i5)', iostat = i)k
<     end if
<     site_ok = .true.
<     if (ijulian < -60) then
<       write(screen,"(a)")
<       write(screen,"(a)")" The time allowed by the password has expired."
<       open(unit=7, file=trim(mopac_pw), form="unformatted")
<       close(7, status="delete")
<       stop
<     end if      
<   end if
<   if (.not. site_ok) then
<     write(screen,"(//,a)")" Before MOPAC2016 can be used, a password must be supplied"
<     write(screen,"(/,a)")" To get a password, send an E-mail request to MrMOPAC@ATT.net"
<     write(screen,"(a)")" "
<     write(screen,"(a)")" To install the password, run MOPAC with the file name equal to the password"
<     write(screen,"(a)")" For example, if the password is 123456789, then run ""MOPAC2016.exe 123456789"""
<     write(screen,"(//,a)") "Password invalid"
<     open(unit=7, file=trim(mopac_pw), form="unformatted")
<     close(7, status="delete")
<     stop
<   end if
<   if (new) then
<     write(screen,"(//a,////)")"         Password for MOPAC2016 successfully installed. Enjoy!"
<     stop
<   end if 
---
>   return
656,700c4
< !function from_MAC_address()
< !  use dfport, only : system
< !  use molkst_C, only: verson
< !  implicit none
< !  integer :: from_MAC_address
< !  character :: line*120, location*30, command*60
< !  integer :: i, j, mac_no
< !  location = "get_MAC_address.txt"
< !
< !  if (verson(7:7) == "W") then
< !!
< !!  Windows-specific code
< !!
< !    command = 'ipconfig /all  > '//trim(location)
< !    j = SYSTEM(trim(command))
< !    if (j /= 0) then
< !      j = 0
< !    end if
< !    open(unit=8, file=trim(location), iostat = j)
< !    if (j /= 0) then
< !      j = 0
< !    end if
< !    do 
< !      read(8,'(a)', iostat = j)line
< !      if (j /= 0) then
< !        j = 0
< !      end if
< !      if (index(line, "Physical Address") /= 0) exit
< !    end do
< !    close(8)
< !    command = 'del /F /q '//trim(location)  
< !    j = SYSTEM(trim(command))
< !    if (j /= 0) then
< !      j = 0
< !    end if
< !    line = line(index(line,":") + 2:)         
< !    mac_no = 0
< !    do i = 1, 6
< !      mac_no = 10*mac_no + 100*ichar(line(i*3 - 2: i*3 - 2)) + 10*ichar(line(i*3 - 1:i*3 - 1))
< !    end do
< !    from_MAC_address = mod(mac_no,71) + 100*mod(mac_no,73) + 10000*mod(mac_no,79) + 1000000*mod(mac_no, 83)
< !    return
< !  end if
< !        
< !end function from_MAC_address
---
> 
Only in .: QuickWin_bits.F90
Only in ../../MOPAC/src/: README.md
diff ./add_hydrogen_atoms.F90 ../../MOPAC/src/add_hydrogen_atoms.F90
2407d2406
<     k = 0
diff ./anavib.F90 ../../MOPAC/src/anavib.F90
10c10
<       use to_screen_C, only : travel, redmas, force_const
---
>       use to_screen_C, only : travel, redmas
36c36
<       logical :: vib1, vib2, vib3, vib4, vib5, vib6
---
>       logical :: vib1, vib2, vib3, vib4, vib5
77,78c77
<         vib5 = .TRUE.
<         vib6 = .TRUE.
---
>         vib5 = .TRUE. 
177c176
<       '(/," VIBRATION",I11,I5,A4, '//num1//'x, "  ATOM PAIR", '//num1//'x, "ENERGY CONTRIBUTION    RADIAL")') &
---
>       '(/," VIBRATION",I5,I5,A4, '//num1//'x, "ATOM PAIR", '//num1//'x, "ENERGY CONTRIBUTION    RADIAL")') &
179c178
<               write (iw, '('' FREQUENCY        '',F9.2,a)') eigs(k), trim(line)
---
>               write (iw, '('' FREQ.   '',F10.2,a)') eigs(k), trim(line)
183c182
<               write (iw, '('' TRANSITION DIPOLE'',F9.4,a)') dipt(k), trim(line)
---
>               write (iw, '('' T-DIPOLE'',F10.4,a)') dipt(k), trim(line)
186c185
<               write (iw, '('' TRAVEL (Ang.)    '',F9.4,a)') travel(k), trim(line)
---
>               write (iw, '('' TRAVEL  '',F10.4,a)') travel(k), trim(line)
189c188
<               write (iw, '('' REDUCED MASS     '',F9.4,a)') redmas(k,1), trim(line)
---
>               write (iw, '('' RED. MASS'',F9.4,a)') redmas(k,1), trim(line)
192,195c191
<               write (iw, '('' EFFECTIVE MASS   '',F9.4,a)') redmas(k,2), trim(line)
<             else if (vib6) then
<               vib6 = .false.
<               write (iw, '('' FORCE CONSTANT   '',F9.4,a)') force_const(k), trim(line)
---
>               write (iw, '('' EFF. MASS'',F9.4,a)') redmas(k,2), trim(line)
208,212c204,207
<         if (vib2) write (iw, '(  '' TRANSITION DIPOLE'',F9.4)') dipt(k) 
<         if (vib3) write (iw, '(  '' TRAVEL (Ang.)    '',F9.4)') travel(k) 
<         if (vib4) write (iw, '(  '' REDUCED MASS     '',F9.4)') redmas(k, 1) 
<         if (vib5) write (iw, '(  '' EFFECTIVE MASS   '',F9.4)') min(9999.9999d0,max(-999.9999d0,redmas(k, 2))) 
<         if (vib6) write (iw, '(  '' FORCE CONSTANT   '',F9.4)') force_const(k)
---
>         if (vib2) write (iw, '(  '' T-DIPOLE '',F9.4)') dipt(k) 
>         if (vib3) write (iw, '(  '' TRAVEL   '',F9.4)') travel(k) 
>         if (vib4) write (iw, '(  '' RED. MASS'',F9.4)') redmas(k, 1) 
>         if (vib5) write (iw, '(  '' EFF. MASS'',F9.4)') min(9999.9999d0,max(-999.9999d0,redmas(k, 2))) 
diff ./bonds.F90 ../../MOPAC/src/bonds.F90
20d19
<       use to_screen_I
diff ./calpar.F90 ../../MOPAC/src/calpar.F90
11c11
<       USE molkst_C, only : keywrd
---
>       USE molkst_C, only : keywrd, method_pm7
diff ./chkion.F90 ../../MOPAC/src/chkion.F90
94c94,97
<       j = index(keywrd(i:), ") ") + i
---
>       do j = i + 6, len_trim(keywrd)
>         if (keywrd(j:j) == " ") exit
>       end do
>       j = index(keywrd(i:j),")") + i
diff ./conref_C.F90 ../../MOPAC/src/conref_C.F90
19c19
<     data fpcref(1, 6) / 6.6260755d-27 /         ! Planck's constant in erg-seconds
---
>     data fpcref(1, 6) / 6.6260755d-27 /         ! Planck's constant in Joule-seconds
diff ./datin.F90 ../../MOPAC/src/datin.F90
282c282
<       USE parameters_C, only : partyp, n_partyp_alpb, n_partyp, v_par, t_par
---
>       USE parameters_C, only : partyp, n_partyp_fn, n_partyp_alpb, n_partyp, v_par, t_par
292c292
<       integer :: i, j, k, l, il, iu, ii, jj, iparam, ielmnt, jelmnt
---
>       integer :: i, j, k, l, il, iu, ii, jj, iparam, ielmnt, jelmnt, j1
Only in ../../MOPAC/src/: deprecated
diff ./dftd3.F90 ../../MOPAC/src/dftd3.F90
15c15
<   use parameters_C, only: par7, par8, par9, par10, par11
---
>   use parameters_C, only: par7, par8, par9
85,88d84
< ! The D3H4 version of the dispersion
< ! Used in PM6-D3H4 and its variants PM6-D3H4X, PM6-D3(H4)
< ! I'VE CHECKED THAT THIS SETUP & THE PARAMETER VALUES READ FROM
< ! parameters_for_PM6 YIELD CORRECT PM6-D3H4 energies
90a87
>         rs18 = 1.0d0
92,94c89,90
<         s18 = par10
<         rs18 = par11
<       else ! hard-wired 
---
>         s18 = 1.009d0
>       else ! hard-wired
95a92
>         alp  = 14.0d0
97d93
<         alp = 14.0d0
126c122
<         call gdisp(xyz, r0ab, rs6, alp6, c6ab, s6, s18,mxc, r2r4, rcov, rs8, alp8, dxyz_temp)
---
>         call gdisp(xyz, r0ab, rs6, alp6, c6ab, s6, mxc, rcov, dxyz_temp)
Only in .: diff.out
diff ./drc.F90 ../../MOPAC/src/drc.F90
7,8c7
<       & errfn, coord, na, p, q, labels
<       USE parameters_C, only : tore
---
>       & errfn, coord, na
12a12
>       use prtdrc_I 
19c19
<         ii, i1, maxcyc, iupper, ilp, io_stat, ilim, iw00, percent, n_escf, n_min, iwd = 9
---
>         ii, i1, maxcyc, iupper, ilp, io_stat, ilim, iw00, percent, n_escf, n_min
29,32c29,31
<         escf_diff, stepx, damp, escf_min, stepxx, dipvec(3), dip
<       logical :: addk, letot, let, velred, opend, parmax, debug, l_debug = .false., l_irc, &
<         l_dipole
<       real(double), external :: ddot, dipole
---
>         escf_diff, stepx, damp, escf_min, stepxx
>       logical :: addk, letot, let, velred, opend, parmax, debug
>       real(double), external :: ddot
83,85c82
<       l_dipole = (index(keywrd,' DIPOLE') /= 0)
<       l_irc = (index(keywrd,' DRC') == 0)
<       if (l_irc) then 
---
>       if (Index (keywrd, " DRC") == 0) then 
132d128
<         if (l_irc) addonk=2.d0  ! Just a guess to get the IRC started
161c157
<       if (.not. l_irc) then 
---
>       if (index(keywrd,' DRC') /= 0) then 
406,414d401
<       if (l_debug) then
< !
< ! Use this block to print diagnostic details of the reaction coordinate
< !
<         line = "debug.txt"
<         call add_path(line)
<         open(iwd, file = trim(line))
<         write(iwd,'(a)')" Point  Velocity      Coordinate      Delta-x    Gradient     ESCF   Deltat*(10^16)"
<       end if
440c427
<         if ((let .or. ekin > 0.2d0) .and. addk) then 
---
>         if ((let .or. ekin>0.2d0) .and. addk) then 
477,483c464,466
<           end do
<           if (l_irc) then
<             velo2 = 0.d0
<             velo3 = 0.d0
<           end if
<           do 
<             do i = 1, nvar
---
>             end do
>             do 
>               do i = 1, nvar
488,492c471,484
<               startv(i) = xparam(i) - 1.d8*( &
<               deltat*velo0(i)*one + &
<               0.5d0*deltat**2*velo1(i) + &
<               0.16666d0*(deltat**2*1.d15)*deltat*velo2(i) + & 
<               0.0416666d0*deltat**2*(1.d30*deltat**2)*velo3(i)) 
---
>                 startv(i) = xparam(i) - 1.d8*( &
>                 deltat*velo0(i)*one + &
>                 0.5d0*deltat**2*velo1(i) + &
>                 0.16666d0*(deltat**2*1.d15)*deltat*velo2(i) + &
>                 0.0416666d0*deltat**2*(1.d30*deltat**2)*velo3(i)) 
>               end do 
>               if (stepxx < 1.d-5) exit
>               sum = 0.d0
>               do i = 1, nvar
>                 sum = sum + (xparam(i) - startv(i))**2
>               end do
>               sum = stepxx/sqrt(sum)
>               if (sum > 0.8d0 .and. sum < 1.25d0) exit
>               deltat = deltat*max(0.99d0, min(1.01d0, sum))
494c486
<             if (stepxx < 1.d-5 .or. (l_irc .and. iloop > 4)) exit
---
>             xparam(:nvar) = startv(:nvar)
496,506c488,491
<             do i = 1, nvar
<               sum = sum + (xparam(i) - startv(i))**2
<             end do
<             sum = stepxx/sqrt(sum)
<             if (sum > 0.8d0 .and. sum < 1.25d0) exit
<             deltat = deltat*max(0.99d0, min(1.01d0, sum))
<           end do
<           sum = 0.d0
<           do i = 1, numat
<             do j = 1,3
<               sum = sum + (geo(j,i) - georef(j,i))**2
---
>             do i = 1, numat
>               do j = 1,3
>                 sum = sum + (geo(j,i) - georef(j,i))**2
>               end do
508,511c493,494
<           end do
<           if (sum > 0.01d0) gnorm = 4.d0
<           if (l_irc) velo0 = 0.d0
<           do i = 1, nvar
---
>             if (sum > 0.01d0) gnorm = 4.d0
>             do i = 1, nvar
542,551d524
<           if (l_debug) then
< !
< ! Use this block to print diagnostic details of the reaction coordinate
< !
<             if (iloop > 25) then
<               write(iwd,'(i6, f10.2, f15.6, f15.6, f10.4, 2f12.6)')iloop, velo0(42)/(const*quadr), &
<               startv(42), startv(42) - xparam(42), grad(42)/4.184D18, escf, deltat*1.d16
<             end if
<           end if
<           xparam(:nvar) = startv(:nvar)
557,561d529
<           if (l_irc) then
<             velo1 = 0.d0
<             velo2 = 0.d0
<             velo3 = 0.d0
<           end if
720c688
<           & abs(average_old_hof - average_new_hof) <0.00001d0) then
---
>           & average_old_hof - average_new_hof <0.0001d0) then
761,766c729
<         deltat = max(minstep,deltat)
<         if (l_dipole) then
<           call chrge (p, q) 
<           q(:numat) = tore(labels(:numat)) - q(:numat)           
<           dip = dipole(p, xparam, dipvec,0)
<         end if
---
>         deltat = max(minstep,deltat) 
778,779c741
<           call prtdrc (deltat, xparam, georef, escf, elost1, gtot, etot, velo0, mcoprt, ncoprt, parmax, &
<           l_dipole, dip)
---
>           call prtdrc (deltat, xparam, georef, elost1, gtot, etot, velo0, mcoprt, ncoprt, parmax) 
792,793c754
<           call prtdrc (deltat, xparam, georef, escf, ekin, dummy, etot, velo0, mcoprt, ncoprt, parmax, &
<           l_dipole, dip) 
---
>           call prtdrc (deltat, xparam, georef, ekin, dummy, etot, velo0, mcoprt, ncoprt, parmax) 
828,829c789
<           call prtdrc (deltat, xparam, georef, escf, ekin, elost, etot, velo0, mcoprt, ncoprt, parmax, &
<           l_dipole, dip) 
---
>           call prtdrc (deltat, xparam, georef, ekin, elost, etot, velo0, mcoprt, ncoprt, parmax) 
diff ./drcout.F90 ../../MOPAC/src/drcout.F90
1,2c1,2
<       subroutine drcout(xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, dip3, &
<         xtot3, iloop, charge, fract, text1, text2, ii, jloop, l_dipole) 
---
>       subroutine drcout(xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, &
>         xtot3, iloop, charge, fract, text1, text2, ii, jloop) 
9c9
<       use maps_C, only : rxn_coord, rc_escf, ekin, rc_dipo
---
>       use maps_C, only : rxn_coord, rc_escf, ekin
13a14
>       use write_trajectory_I
20,21c21
<         escf3(3), ekin3(3), etot3(3), dip3(3), xtot3(3), charge(natoms) 
<       logical, intent (in) :: l_dipole
---
>         escf3(3), ekin3(3), etot3(3), xtot3(3), charge(natoms) 
47c47
<         run_local = (index(keywrd,' LOCAL') + index(keywrd,' RABBIT') + index(keywrd,' BANANA') /= 0)
---
>         run_local = (index(keywrd,' LOCAL') /= 0)
60c60
<       if (jloop==0 .or. (jloop/iprint)*iprint==jloop) then               
---
>       if (jloop==0 .or. (jloop/iprint)*iprint==jloop) then 
62c62,64
<           write (line, '('' FEMTOSECONDS  POINT  POTENTIAL + KINETIC  =   TOTAL     ERROR    REF%   MOVEMENT'')') 
---
>           write (line, &
>       '('' FEMTOSECONDS  POINT  POTENTIAL +''         ,'' KINETIC  =   TOTAL &
>       &    ERROR    REF%   MOVEMENT'')') 
64c66,67
<           write (line, '(''     POINT   POTENTIAL  +  ENERGY LOST   =   TOTAL      ERROR    REF%   MOVEMENT'')') 
---
>           write (line, &
>       '(''     POINT   POTENTIAL  +  ENERGY LOST   =   TOTAL      ERROR    REF%   MOVEMENT'')') 
80d82
<       rc_dipo = dip3(1) + dip3(2)*fract + dip3(3)*fract**2 
133,134c135,136
<           end if
<         end if        
---
>           endif 
>         endif 
178c180
<         call write_trajectory(xyz, rc_escf, ekin, rc_dipo, time, rxn_coord, l_dipole)
---
>         call write_trajectory(xyz, 1, charge, rc_escf, ekin, time, rxn_coord)
180c182
<         call write_trajectory(xyz, rc_escf, errr, rc_dipo, 0.d0, rxn_coord, l_dipole)
---
>         call write_trajectory(xyz, 1, charge, rc_escf, errr, 0.d0, rxn_coord)
Only in ../../MOPAC/src/: drcout_I.F90
diff ./ef.F90 ../../MOPAC/src/ef.F90
91,92d90
<     tstep = 0.d0
<     tprt = 0.d0
198c196
<       write (iw, '(/, 5 x, "GRADIENT =", f9.5, " IS LESS THAN CUTOFF =", f9.5,//)') rmx, tol2
---
>       write (iw, '(/, 5 x, "GRADIENT =", f9.5, "  IS LESS THAN CUTOFF =", f9.5,//)') rmx, tol2
366c364
<         write (iw, '(/, 5 x, "GRADIENT =", f9.5, " IS LESS THAN CUTOFF =", f9.5,//)') rmx, tol2
---
>         write (iw, '(/, 5 x, "GRADIENT =", f9.5, "  IS LESS THAN CUTOFF =", f9.5,//)') rmx, tol2
1540d1537
<     use to_screen_I
diff ./ef_C.F90 ../../MOPAC/src/ef_C.F90
10,11c10,11
<         real(double), dimension(:), allocatable :: vref, vref0, now  
<         real(double), dimension(:,:), allocatable :: allxyz, allvel, xyz3, vel3, allgeo, geo3 
---
>         real(double), dimension(:), allocatable :: vref, vref0 
>         real(double), dimension(:,:), allocatable :: allxyz, allvel, xyz3, vel3, allgeo, geo3  
diff ./esp.F90 ../../MOPAC/src/esp.F90
438d437
<       use to_screen_I
diff ./fmat.F90 ../../MOPAC/src/fmat.F90
61c61
< !          = 4.184/6.0221367d23*10^21
---
>     !  fact = 1.d0/627.51*0.529**2
87c87
<       big = (index(keywrd,'LARGE') /= 0 .and. debug) 
---
>       big = index(keywrd,'LARGE')/=0 .and. debug 
124a125
>      ! numat = nvar/3 
157a159,161
> 
> ! For MOPAC BLAS          
> !          delta = delta*10.D0/sqrt(dot(g2old,g2old,nvar))
163c167
<           if (debug) write (iw, '(A,I3,A,F15.8)') ' STEP:', i, ' DELTA :', delta 
---
>           if (debug) write (iw, '(A,I3,A,F12.5)') ' STEP:', i, ' DELTA :', delta 
171a176,177
>             !& sqrt(dot(g2old,g2old,nvar)) 
> !! For MOPAC BLAS                                
179a186,187
>             !sqrt(dot(g2rad,g2rad,nvar))             
> ! MOPAC BLAS            
181c189
<           if (debug) write (iw, '(A,I3,A,F15.8)') ' STEP:', i, ' DELTA :', delta 
---
>           if (debug) write (iw, '(A,I3,A,F12.5)') ' STEP:', i, ' DELTA :', delta 
diff ./force.F90 ../../MOPAC/src/force.F90
17c17
<       use to_screen_C, only : dipt, travel, freq, redmas, cnorml, force_const
---
>       use to_screen_C, only : dipt, travel, freq, redmas, cnorml
26a27
>       use write_trajectory_I
166,174c167,174
<       if (allocated(grad))            deallocate (grad)
<       if (allocated(errfn))           deallocate (errfn)
<       if (allocated(dipt))            deallocate (dipt)
<       if (allocated(travel))          deallocate (travel)
<       if (allocated(force_const))     deallocate (force_const)
<       if (allocated(freq))            deallocate (freq)
<       if (allocated(redmas))          deallocate (redmas)
<       if (allocated(cnorml))          deallocate (cnorml)
<       if (allocated(fmatrx))          deallocate (fmatrx)
---
>       if (allocated(grad))    deallocate (grad)
>       if (allocated(errfn))   deallocate (errfn)
>       if (allocated(dipt))    deallocate (dipt)
>       if (allocated(travel))  deallocate (travel)
>       if (allocated(freq))    deallocate (freq)
>       if (allocated(redmas))  deallocate (redmas)
>       if (allocated(cnorml))  deallocate (cnorml)
>       if (allocated(fmatrx))  deallocate (fmatrx)
177c177
<        travel(3*numat), force_const(3*numat), freq(3*numat), redmas(3*numat,2), stat = j)
---
>        travel(3*numat), freq(3*numat), redmas(3*numat,2), stat = j)
266,267c266
<       '(2/10X,''SYMMETRY WAS SPECIFIED, BUT CANNOT BE USED HERE'')')
<       c = 1.d0
---
>       '(2/10X,''SYMMETRY WAS SPECIFIED, BUT CANNOT BE USED HERE'')') 
398c397
<       call freqcy (fmatrx, freq, travel, force_const, .TRUE., deldip, ff, oldf, ts) 
---
>       call freqcy (fmatrx, freq, travel, .TRUE., deldip, ff, oldf, ts) 
496,499c495
<         if (index(keywrd, " HTML") /= 0) then
<            if (index(keywrd,' DIPOLE') /= 0) call write_path_html(2)
<            call write_path_html(1)
<         end if
---
>         if (index(keywrd, " HTML") /= 0) call write_path_html
549,551c545,546
<             If (index(keywrd,' DIPOLE') /= 0) call reverse_trajectory(2)
<             call reverse_trajectory(1)
<             call reverse_aux
---
>           call write_trajectory(geo, 2)
>           call reverse_aux
588c583
<       call freqcy (fmatrx, freq, deldip, force_const, .FALSE., deldip, ff, oldf, ts) 
---
>       call freqcy (fmatrx, freq, deldip, .FALSE., deldip, ff, oldf, ts) 
diff ./freqcy.F90 ../../MOPAC/src/freqcy.F90
1c1
<       subroutine freqcy(fmatrx, freq, travel, force_const, eorc, deldip, ff, oldf, ts) 
---
>       subroutine freqcy(fmatrx, freq, travel, eorc, deldip, ff, oldf, ts) 
20c20
<       real(double) , intent(out) :: travel(3*numat), force_const(3*numat) 
---
>       real(double) , intent(out) :: travel(3*numat) 
26c26,27
<       real(double) :: fact, c2pi, sumerr, sum, err, weight, summ, sum1 
---
>       real(double) :: fact, c2pi, sumerr, sum, err, weight, const, summ, &
>         sum1 
153a155,159
> !     CONST = SQRT(2*h*c*1.D11) = conversion from cm**(-1) to
> !             dyne-Angstroms
> !
>       const = sqrt(2.D0*fpc_6*fpc_8*1.D11) 
> !
197d202
<         force_const(i) = freq(i)*redmas(i,1)*1.d-5
199,207d203
< !
< ! Convert frequency into SI units (ergs)
< !
<         sum = freq(i)*fpc_6*fpc_8
< !
< ! Travel, in Angstroms
< !
<         travel(i) = sqrt(2.d0*sum/(force_const(i)*1.d5))*1.d8
<         if (travel(i) > 1.D0) travel(i) = 0.D0 
212a209,219
> !
> !    CONST=SQRT(A*B*C) WHERE
> !         A= CONVERSION OF CM**(-1) TO (ERGS PER ATOM = DYNE.ANGSTROMS)
> !         B= MILLIDYNES TO DYNES
> !         C= CENTIMETERS TO ANGSTROMS
> !
> !         TRAVEL(I)=SUM1*0.0063024D0
> !
>         if (sum<0.D0 .or. sum>100) sum = 0.D0 
>         travel(i) = sum1*const 
>         if (travel(i) > 1.D0) travel(i) = 0.D0 
diff ./gdisp.F90 ../../MOPAC/src/gdisp.F90
1c1
<   subroutine gdisp(xyz, r0ab, rs6, alp6, c6ab, s6, s8, mxc, r2r4, rcov, rs8, alp8, dxyz_temp)
---
>   subroutine gdisp(xyz, r0ab, rs6, alp6, c6ab, s6, mxc, rcov, dxyz_temp)
21c21
<   rs6, alp6, s6, s8, r2r4(max_elem), rs8, alp8
---
>   rs6, alp6, s6
27,28c27,28
<   double precision :: R0, r2, damp6, damp8, c6, tmp1, tmp2, r, dc6_rest, rij(3), dc6iji, dc6ijj, r6, r7, t6, t8, &
<   rcovij, expterm, dcn,x1, r42, r8, r9
---
>   double precision :: R0, r2, damp6, c6, tmp1, r, dc6_rest, rij(3), dc6iji, dc6ijj, r6, r7, t6, &
>   rcovij, expterm, dcn,x1
44d43
<       r42=r2r4(nat(i))*r2r4(nat(j))
51,52d49
<       r8=r6*r2
<       r9=r8*r
58,59d54
<       t8 = (r/(rs8*R0))**(-alp8)
<           damp8 =1.d0/( 1.d0+6.d0*t8 )
61,64c56,58
<       tmp2=s8*6.d0*C6*r42*damp8/r9
<       drij(linij) = drij(linij) - tmp1 - 4.d0*tmp2 
<       drij(linij) = drij(linij)  + tmp1*alp6*t6*damp6 +3.d0*tmp2*alp8*t8*damp8  
<       dc6_rest = s6/r6*damp6 +3.d0*s8*r42/r8*damp8
---
>       drij(linij) = drij(linij) - tmp1  
>       drij(linij) = drij(linij)  + tmp1*alp6*t6*damp6   
>       dc6_rest = s6/r6*damp6 
94d87
<   return
diff ./geochk.F90 ../../MOPAC/src/geochk.F90
1425,1428c1425
<       j = max(abs(ichrge), abs(irefq))
<       k = min(ichrge, irefq)
<       num = char(ichar("2") + max(int(log10(j + 0.05)),0))
<       if (k < 0) num = char(ichar(num) + 1)
---
>        num = char(ichar("2") + max(int(log10(abs(ichrge) + 0.05)),0))
1436d1432
<             if (index(keywrd," CHARGE=") /= 0) &
diff ./geochk_bits_1.F90 ../../MOPAC/src/geochk_bits_1.F90
23c23,26
<     if (i /= 0) j = index(keywrd(i:),") ") + i
---
>     if (i /= 0) then
>       j = index(keywrd(i + 1:)," ") + i + 1
>       j = index(keywrd(i:j),") ") + i
>     end if
89,91c92
<       i = 0
<       do k = 1, len_trim(txt_rad)
<         i = i + 1
---
>       do i = 1, len_trim(txt_rad)
98d98
<             i = i + int(log10(j*1.0001))
diff ./geochk_bits_2.F90 ../../MOPAC/src/geochk_bits_2.F90
585,588d584
< !
< !  In the next block "txt_to_atom_no" cannot be used, because the PDB text is
< !  needed for recognizing the atom.
< !
diff ./geout.F90 ../../MOPAC/src/geout.F90
55d54
<       if (index(keywrd, " NOTXT") /= 0) maxtxt = 0
111,113c110,112
<         x = 1.d-8
<         y = 1.d-8
<         z = 1.d-8
---
>         x = 0.d0
>         y = 0.d0
>         z = 0.d0
diff ./getgeo.F90 ../../MOPAC/src/getgeo.F90
482d481
<       pdb_label = (maxtxt > 25)
484a484
>         pdb_label = (maxtxt == 26)
489c489
<         call txt_to_atom_no(line, istart(10), .false.)
---
>         call txt_to_atom_no(line, istart(10), .false., j)
491,492c491,492
<       if (line(istart(9):istart(9)) == '"')   call txt_to_atom_no(line, istart(9), .false.)
<       if (line(istart(8):istart(8)) == '"')   call txt_to_atom_no(line, istart(8), .false.)
---
>       if (line(istart(9):istart(9)) == '"')   call txt_to_atom_no(line, istart(9), .false., j)
>       if (line(istart(8):istart(8)) == '"')   call txt_to_atom_no(line, istart(8), .false., j)
diff ./getsym.F90 ../../MOPAC/src/getsym.F90
116c116
<         call txt_to_atom_no(line, i, .false.)
---
>         call txt_to_atom_no(line, i, .false., j)
diff ./grid.F90 ../../MOPAC/src/grid.F90
163d162
<       cputot = 0.d0
200a200
>         cputot = 0.d0
diff ./iter.F90 ../../MOPAC/src/iter.F90
38d37
<       use to_screen_I
1013d1011
<       use to_screen_I
diff ./iter_for_MOZYME.F90 ../../MOPAC/src/iter_for_MOZYME.F90
20d19
<     use to_screen_I
diff ./lewis.F90 ../../MOPAC/src/lewis.F90
516,517c516,528
<         call txt_to_atom_no(keywrd, j - 1, let)
<         if (moperr) return      
---
>         call txt_to_atom_no(keywrd, j - 1, let, m)
>         if (moperr) return
>         if (m > numat) then
>           if (let) then
> !
> !  Jump over the faulty atom label
> !
>             k = Index (keywrd(i:), ")") + i
>             i = index(keywrd(i:k),"""") + i  
>             i = index(keywrd(i:k),"""") + i  
>             cycle
>           end if
>         end if        
737c748
<   subroutine txt_to_atom_no(text, j_in, let)
---
>   subroutine txt_to_atom_no(text, j_in, let, m)
752a764
>   integer, intent (out) :: m
754c766
<   integer :: i, j, l, n, k, m
---
>   integer :: i, j, l, n, k
diff ./ligand.F90 ../../MOPAC/src/ligand.F90
253d252
<           n = 0
diff ./linmin.F90 ../../MOPAC/src/linmin.F90
19d18
<       use to_screen_I
diff ./local.F90 ../../MOPAC/src/local.F90
15a16
>       use resolv_I 
17d17
<       use to_screen_I
27a28
>       real(double)  :: cold(norbs,norbs) 
40,41c41
<       character :: elemnt(99)*2, num_1*1, num_2*1 
<       real(double), allocatable  :: cold(:,:) 
---
>       character, dimension(99) :: elemnt*2 
75c75
<       eps = 1.0D-10 
---
>       eps = 1.0D-7 
77,81d76
<       allocate (cold(norbs,norbs), stat = i)
<        if (i /= 0) then
<         call memory_error ("Unable to allocate memory in LOCAL")
<         return
<       end if
145d139
<       psi1(:nocc) = 0.d0
155d148
<           psi1(i) = psi1(i) + x*x
163,166c156
<       do i = 1, nocc
<         psi1(i) = 1.d0/psi1(i)
<       end do
<       call resolv (c, cold, norbs, eig, nocc, psi1) 
---
>       call resolv (c, cold, norbs, eig, nocc) 
202,207c192,197
<         num_1 = char(ichar("1") +int(log10(numat + 0.05)))
<         write (iw, "(/,10x,'NUMBER OF ITERATIONS =',i4,/,10x,'LOCALIZATION VALUE =',f14.9,/)") iter, sum1 
<         write (iw, "("//num_1//"x,'NUMBER OF CENTERS  LMO ENERGY     COMPOSITION OF ORBITALS ')")   
<         write (iw, "("//num_1//"x,34x,'(AS PERCENT OF THE LMO)',/)") 
<         num_1 = char(ichar("3") +int(log10(numat + 0.05)))
<         num_2 = char(ichar("1") +int(log10(norbs + 0.05)))
---
>         write (iw, 110) iter, sum1 
>   110 format(/,10x,'NUMBER OF ITERATIONS =',i4,/,10x,'LOCALISATION VALUE =',f&
>         14.9,/) 
>         write (iw, 120) 
>   120 format(3x,'NUMBER OF CENTERS',14x,'(COMPOSITION OF ORBITALS)'/,/)   
>        
235,252c225,226
<           if (ii == 1) then
<             if (cii(1) > 99.949d0) then
<               write (iw, '(i'//num_1//',f10.4,f17.5, 3x,a2,i'//num_2//',f6.1)') i, x,eig(i), elemnt(nat(iel(1))),iel(1),cii(1) 
<             else
<               write (iw, '(i'//num_1//',f10.4,f17.5, 3x,a2,i'//num_2//',f6.2)') i, x,eig(i), elemnt(nat(iel(1))),iel(1),cii(1)
<             end if
<           else
<             if (ii < 6) then
<               write (iw, '(i'//num_1//',f10.4,f17.5, 5(3x,a2,i'//num_2//',f6.2))') &
<               i, x,eig(i), (elemnt(nat(iel(k))),iel(k),cii(k),k=1,ii) 
<             else if (ii < 11) then
<               write (iw, '(i'//num_1//',f10.4,f17.5, 5(3x,a2,i'//num_2//',f6.2),/31x,5(3x,a2,i'//num_2//',f6.2))') &
<               i, x,eig(i), (elemnt(nat(iel(k))),iel(k),cii(k),k=1,ii) 
<             else
<               write (iw, '(i'//num_1//',f10.4,f17.5, 5(3x,a2,i'//num_2//',f6.2),2(/31x,5(3x,a2,i'//num_2//',f6.2)))') &
<               i, x,eig(i), (elemnt(nat(iel(k))),iel(k),cii(k),k=1,ii)           
<             end if 
<           end if
---
>           write (iw, 240) x, (elemnt(nat(iel(k))),iel(k),cii(k),k=1,ii) 
>     240   format(f10.4,4(5(3x,a2,i3,f6.2),/,10x)) 
253a228
>   260 format(/,/,20x,' LOCALIZED ORBITALS ',/,/) 
255,261c230,231
<         if (numat > 25 .and. index(keywrd, "LARGE") == 0) then
<           write(iw,'(/10x,a)')"Localized orbitals for systems of over 25 atoms are not printed by default"
<           write(iw,'(10x,a)')"(To print localized orbitals, add keyword ""LARGE"")"
<         else
<           write (iw, "(/,/,20x,' LOCALIZED ORBITALS ',/,/)") 
<           call matout (c, eig, nocc, norbs, norbs) 
<         end if
---
>         write (iw, 260) 
>         call matout (c, eig, nocc, norbs, norbs) 
diff ./local_for_MOZYME.F90 ../../MOPAC/src/local_for_MOZYME.F90
10c10
<     double precision :: totij, sum
---
>     double precision :: totij
25,27c25,26
<              & nocc, iorbs, psi1, psi2, axiiii, nf, nl, ioc, nncf, totij, sum)
<    !     write (iw, "(10x,'NUMBER OF ITERATIONS =',i4,/,10x,'LOCALIZATION VALUE =',f14.9)") i, sum 
<         if (totij < 1.d-5) exit
---
>              & nocc, iorbs, psi1, psi2, axiiii, nf, nl, ioc, nncf, totij)
>         if (totij < 1.d-10) exit
29,32d27
<       write (iw, "(10x,'NUMBER OF ITERATIONS =',i4,/,10x,'LOCALIZATION VALUE =',f14.9,/)") i, sum 
< !
<       call MOZYME_eigs(nocc)
< !
39,40c34,35
<              & nnce, totij, sum)
<         if (totij < 1.d-5) exit
---
>              & nnce, totij)
>         if (totij < 1.d-10) exit
50c45
<      & psi2, axiiii, nf, nl, ioc, nnc_loc, totij, total)
---
>      & psi2, axiiii, nf, nl, ioc, nnc_loc, totij)
54c49
<     double precision, intent (out) :: totij, total
---
>     double precision, intent (out) :: totij
65c60
<     double precision :: aij, bij, ca, dii, dij, djj, sa, xiiii, xiijj, &
---
>     double precision :: aij, bij, ca, dii, dij, djj, sa, total, xiiii, xiijj, &
171c166
<             if (sa > 1.d-14) then
---
>             if (sa > 1.0d-14) then
192d186
<     return
diff ./maps_C.F90 ../../MOPAC/src/maps_C.F90
25d24
<   &  rc_dipo,     &  !  Reaction coordinate dipole
diff ./moldat.F90 ../../MOPAC/src/moldat.F90
53d52
<       use to_screen_I
1118d1116
<   use to_screen_I
1177d1174
<       use to_screen_I
Only in .: mopac for export.F90
diff ./mopac.F90 ../../MOPAC/src/mopac.F90
13,16c13,14
< ! To by-pass "password" replace the following line with: "site_no = 999".   
<   call password 
< !  academic = .false.
< !  site_no = 999 
---
> ! To by-pass "password" replace the following line with: "site_no = 999".
>   call password  
diff ./mpcsyb.F90 ../../MOPAC/src/mpcsyb.F90
72d71
<       use to_screen_I
diff ./mult_symm_AB.F90 ../../MOPAC/src/mult_symm_AB.F90
9a10
> #if GPU
11a13
> #endif
35a38
> #if GPU
38a42
> #endif
113a118
> #if GPU
116c121
<             
---
> #endif
diff ./nllsq.F90 ../../MOPAC/src/nllsq.F90
18d17
<       use to_screen_I
diff ./parameters_for_PM6_C.F90 ../../MOPAC/src/parameters_for_PM6_C.F90
1437,1441c1437,1439
<       data   v_par6(7)/    0.880000d0/  ! Used in dftd3 to set "s6"  in D3H4
<       data   v_par6(8)/   22.000000d0/  ! Used in dftd3 to set "alp" in D3H4
<       data   v_par6(9)/    1.180000d0/  ! Used in dftd3 to set "rs6" in D3H4
<       data   v_par6(10)/    0.0d0/      ! Used in dftd3 to set "s8" in D3H4
<       data   v_par6(11)/    1.0d0/      ! Used in dftd3 to set "rs8" in D3H4
---
>       data   v_par6(7)/    1.000000d0/  ! Used in dftd3 to set "s6"  in D3H4
>       data   v_par6(8)/   14.000000d0/  ! Used in dftd3 to set "alp" in D3H4
>       data   v_par6(9)/    1.560000d0/  ! Used in dftd3 to set "rs6" in D3H4
diff ./parameters_for_PM7_TS_C.F90 ../../MOPAC/src/parameters_for_PM7_TS_C.F90
7d6
<     real(double), dimension(60) :: v_par7_TS
1345a1345,1354
>       data gues7_TS1( 99,1)/         8.947612D0/ ! = PAR1
>       data gues7_TS2( 99,1)/         6.024265D0/ ! = PAR2
>       data gues7_TS3( 99,1)/        -0.012037D0/ ! = PAR3
>       data gues7_TS1( 99,2)/         0.701333D0/ ! = PAR4
>       data gues7_TS2( 99,2)/        15.450118D0/ ! = PAR5
>       data gues7_TS3( 99,2)/         1.226593D0/ ! = PAR6
>       data gues7_TS1( 99,3)/         2.286419D0/ ! = PAR7
>       data gues7_TS2( 99,3)/        -0.171271D0/ ! = PAR8
>       data gues7_TS3( 99,3)/        -0.098822D0/ ! = PAR9
>       data gues7_TS1( 99,4)/        -0.308057D0/ ! = PAR10
1377,1387d1385
<       !
< !                     Global parameters
< !
< !
<       data   v_par7_TS(1)/    8.947612d0/  ! Used in ccrep for scalar correction of C-C triple bonds.
<       data   v_par7_TS(2)/    6.024265d0/  ! Used in ccrep for exponent correction of C-C triple bonds.
<       data   v_par7_TS(3)/   -0.012037d0/  ! Used in ccrep for scalar correction of O-H term.
<       data   v_par7_TS(4)/    0.701333d0/  ! Used in ccrep for exponent correction of C-C triple bonds.
<       data   v_par7_TS(7)/    0.900000d0/  ! Used in dftd3 to set "s6"  in D3H4
<       data   v_par7_TS(8)/   14.000000d0/  ! Used in dftd3 to set "alp" in D3H4
<       data   v_par7_TS(9)/    1.561000d0/  ! Used in dftd3 to set "rs6" in D3H4
diff ./pathk.F90 ../../MOPAC/src/pathk.F90
11c11
<         loc, grad, all_comments, p, q, labels
---
>         loc, grad, all_comments
15d14
<       USE parameters_C, only : tore
40,43c39,43
<         imodel = 0, ixyz1
<       real(double) :: step, degree, c1, cputot, cpu1, cpu2, cpu3, stepc1, factor, dip, &
<         dipvec(3), xdfp(20),  gd(3*numat), xlast(3*numat) 
<       logical :: use_lbfgs, opend, scale, debug, l_dipole
---
>         imodel = 0
>       real(double), dimension(3*numat) :: gd, xlast 
>       real(double), dimension(20) :: xdfp 
>       real(double) :: step, degree, c1, cputot, cpu1, cpu2, cpu3, stepc1, factor
>       logical :: use_lbfgs, opend, scale, debug
45d44
<       real(double), external :: dipole
50d48
<       l_dipole = (index(keywrd, " DIPOLE") /= 0)
82,85d79
<       if (l_dipole) then
<       ixyz1 = ixyz + 1
<       open(unit=ixyz1, file=xyz_fn(:len_trim(xyz_fn) - 4)//" for dipole.xyz")
<     end if   
138,141c132
<       if (index(keywrd, " HTML") /= 0) then
<         if (index(keywrd,' DIPOLE') /= 0) call write_path_html(2)
<         call write_path_html(1)
<       end if
---
>       if (index(keywrd, " HTML") /= 0) call write_path_html
219,229d209
<         if (l_dipole) then
<           call chrge (p, q) 
<           q(:numat) = tore(labels(:numat)) - q(:numat)           
<           dip = dipole(p, coord, dipvec,0)
<           write(ixyz1,"(i6,a)") nl_atoms," "
<           write(ixyz1,'(a, i'//num1//', a, f1'//num2//'.3, a, f1'//num3//'.3, a)')"Profile.", iloop, &
<           " DIPOLE =", dip, " DEBYE"
<           do i = 1, numat
<             if (l_atom(i)) write(ixyz1,"(3x,a2,3f15.5)")elemnt(nat(i)), (coord(l,i),l=1,3)
<           end do
<         end if
275c255
<   subroutine write_path_html(mode)
---
>   subroutine write_path_html
279d258
<     integer, intent (in) :: mode
283,287c262
<     if (mode == 1) then
<       line = input_fn(:len_trim(input_fn) - 4)//"html"
<     else
<       line = input_fn(:len_trim(input_fn) - 5)//" for dipole.html"
<     end if
---
>     line = input_fn(:len_trim(input_fn) - 4)//"html"
328,332c303
<     if (mode == 1) then
<       line = input_fn(:len_trim(input_fn) - 4)//"xyz"
<     else
<       line = input_fn(:len_trim(input_fn) - 5)//" for dipole.xyz"
<     end if
---
>     line = input_fn(:len_trim(input_fn) - 4)//"xyz"
375,379c346
<     if (mode == 2) then
<       write(iprt,"(a)")"  var label =  'Model = ' + modelnumber + ', Dipole = ' + roundoff(energy,3) + ' Debye'"
<     else
<       write(iprt,"(a)")"  var label =  'Model = ' + modelnumber + ', Energy = ' + roundoff(energy,3) + ' Kcal/mol'"
<     end if
---
>     write(iprt,"(a)")"  var label =  'Model = ' + modelnumber + ', Energy = ' + roundoff(energy,3) + ' Kcal/mol'"
463,467c430
<     if (mode == 2) then
<       write(iprt,"(a)")"   var label = ""&nbsp;&nbsp;Model ""+ model + "", Dipole = "" + y +"" Debye"""
<     else
<       write(iprt,"(a)")"   var label = ""&nbsp;&nbsp;Model ""+ model + "", Energy = "" + y +"" Kcal/mol)"""
<     end if
---
>     write(iprt,"(a)")"   var label = ""&nbsp;&nbsp;Model ""+ model + "", Energy = "" + y +"" Kcal/mol)"""
diff ./pinout.F90 ../../MOPAC/src/pinout.F90
13c13
<     use to_screen_I
---
> 
diff ./polar.F90 ../../MOPAC/src/polar.F90
776d775
<       use to_screen_I
Only in .: port.mop.txt
diff ./post_scf_corrections.F90 ../../MOPAC/src/post_scf_corrections.F90
63d62
<   if (.not. allocated(dxyz)) allocate (dxyz(1))
diff ./powsq.F90 ../../MOPAC/src/powsq.F90
14d13
<       use to_screen_I
135d133
<       test = 0.d0
diff ./prtdrc.F90 ../../MOPAC/src/prtdrc.F90
1,2c1
<       subroutine prtdrc(deltt, xparam, ref, escf, ekin, gtot, etot, velo0, mcoprt, ncoprt, parmax, &
<           l_dipole, dip) 
---
>       subroutine prtdrc(deltt, xparam, ref, ekin, gtot, etot, velo0, mcoprt, ncoprt, parmax) 
7c6
<       USE molkst_C, only : numat, keywrd, numcal, nvar, jloop => itemp_1
---
>       USE molkst_C, only : numat, keywrd, numcal, escf, nvar, jloop => itemp_1
12c11
<         time, now
---
>         time
16a16
>       use drcout_I 
19c19,20
<       real(double) , intent(in) :: deltt, escf, ekin, dip
---
>       real(double) , intent(in) :: deltt 
>       real(double) , intent(in) :: ekin 
21d21
<       logical, intent (in) :: l_dipole
33c33
<       real(double), dimension(3) :: etot3, xtot3, dip3 
---
>       real(double), dimension(3) :: etot3, xtot3 
35c35
<         xold0, xold1, xold2, refscf, totime, told2, told1, refx, tlast, old_sum, &
---
>         xold0, xold1, xold2, refscf, totime, told2, told1, refx, tlast, &
37,38c37
<         sum, deltat, t1, t2, sum1, dh, cc, bb, aa, c1, fract, dip2, dip1, dip0, &
<         suma, sumb
---
>         sum, deltat, t1, t2, sum1, dh, cc, bb, aa, c1, fract
45c44
<         tref, xtot0, xtot1, xtot2, dip1, dip0, old_sum
---
>         tref, xtot0, xtot1, xtot2
74d72
<         if (allocated(now)) deallocate(now)
77,79c75
<         allgeo(3,i), geo3(3,i), parref(i), now(i) )
<         now = ref
<         old_sum = 0.d0
---
>         allgeo(3,i), geo3(3,i), parref(i) )
209,214c205
<       endif
<       if (iloop > 100 .and. jloop < 3) then
<         call mopend("Step size is too large for a path to be generated")
<         return
<       end if
<       c1 = 0.d0
---
>       endif 
246,248c237
<         ekin0 = ekin
<         dip1 = dip
<         dip0 = dip
---
>         ekin0 = ekin 
293,296d281
<       dip2 = dip1 
<       dip1 = dip0 
<       dip0 = dip 
<       call quadr (dip2, dip1, dip0, t1, t2, dip3(1), dip3(2), dip3(3)) 
314c299,300
<       l = 0
---
>       xold0 = 0.D0 
>       l = 0 
316d301
<       sum = 0.D0 
319,320c304,305
<         suma = 0.d0
<         sumb = 0.d0
---
>         sum = 0.D0 
>         sum1 = 0.D0 
323,324c308,309
<           suma = suma + (allxyz(1,l) - ref(l))**2 
<           sumb = sumb + (allxyz(1,l) - now(l))**2
---
>           sum1 = sum1 + (allxyz(1,l)-ref(l))**2 
>           sum = sum + (allxyz(2,l)-allxyz(1,l))**2 
326,328d310
<         sum = sum + sqrt(sumb)
<         sum1 = sum1 + sqrt(suma)
<       end do 
332,335c314,316
< !
<       xold0 =  sum - old_sum
<       xtot0 = xtot0 + sum1 
<       old_sum = sum      
---
>         xold0 = xold0 + sqrt(sum) 
>         xtot0 = xtot0 + sqrt(sum1) 
>       end do 
452,453c433,434
<             call drcout (xyz3, geo3, vel3, nvar, totime, escf3, ekin3, etot3, dip3, &
<               xtot3, iloop, charge, fract, text1, text2, ii, jloop, l_dipole) 
---
>             call drcout (xyz3, geo3, vel3, nvar, totime, escf3, ekin3, etot3, &
>               xtot3, iloop, charge, fract, text1, text2, ii, jloop) 
469,470c450,451
<               call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, dip3, &
<                 xtot3, iloop, charge, fract, text1, text2, k, jloop, l_dipole) 
---
>               call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, &
>                 xtot3, iloop, charge, fract, text1, text2, k, jloop) 
497,498c478,479
<               call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, dip3, &
<                 xtot3, iloop, charge, fract, text1, text2, 0, jloop, l_dipole) 
---
>               call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, &
>                 xtot3, iloop, charge, fract, text1, text2, 0, jloop) 
507,508c488,489
<               call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, dip3, &
<                 xtot3, iloop, charge, tsteps(i), text1, text2, 0, jloop, l_dipole) 
---
>               call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, &
>                 xtot3, iloop, charge, tsteps(i), text1, text2, 0, jloop) 
510,511d490
<             old_sum = 0.d0
<             now(:) = allxyz(1,:)
528,529c507,508
<             call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, dip3, &
<               xtot3, iloop, charge, fract, text1, text2, k, jloop, l_dipole) 
---
>             call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, &
>               xtot3, iloop, charge, fract, text1, text2, k, jloop) 
537,538c516,517
<         call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, dip3, &
<                 xtot3, iloop, charge, fract, text1, text2, 0, jloop, l_dipole)         
---
>         call drcout (xyz3, geo3, vel3, nvar, time, escf3, ekin3, etot3, &
>                 xtot3, iloop, charge, fract, text1, text2, 0, jloop)         
Only in ../../MOPAC/src/: prtdrc_I.F90
diff ./prtlmo.F90 ../../MOPAC/src/prtlmo.F90
2c2
<     use molkst_C, only: norbs, keywrd, numat
---
>     use molkst_C, only: norbs
12d11
<     character :: num_1*1
21,22c20,22
<     num_1 = char(ichar("1") +int(log10(numat + 0.05)))
<     write (iw,'(10x,a)') "LOCALIZED MOLECULAR ORBITALS"
---
>      write (iw,*) " LOCALIZED MOLECULAR ORBITALS"
>      write (iw, "(/,2A,/)") " (PSI**2 IS 10000 TIMES THE ", &
>    & "SQUARE OF THE WAVE-FUNCTION ON AN ATOM)"
27,28c27,28
<     write (iw, "("//num_1//"x,'NUMBER OF CENTERS  LMO ENERGY     COMPOSITION OF ORBITALS ')")   
<     write (iw, "("//num_1//"x,34x,'(AS PERCENT OF THE LMO)',/)") 
---
>     write (iw, "(2A)") "  LMO   ENERGY    ATOM PSI**2  ATOM", &
>    & " PSI**2  ATOM PSI**2  ATOM PSI**2  ATOM PSI**2"
30d29
<     if (index(keywrd, " ALLVEC") /= 0) then
34,37c33,36
<       write (iw,'(/10x,a,/)') " Virtual Set (NOT re-localized!)"
<       write (iw, "("//num_1//"x,'NUMBER OF CENTERS  LMO ENERGY     COMPOSITION OF ORBITALS ')")   
<       write (iw, "("//num_1//"x,34x,'(AS PERCENT OF THE LMO)',/)") 
<       call prtlmn (nnce, icvir, ncvir, cvir, nce, isort(noccupied + 1:), &
---
>     write (iw,'(/10x,a,/)') " Virtual Set"
>     write (iw, "(2A)") "  LMO   ENERGY    ATOM PSI**2  ATOM", &
>    & " PSI**2  ATOM PSI**2  ATOM PSI**2  ATOM PSI**2"
>     call prtlmn (nnce, icvir, ncvir, cvir, nce, isort(noccupied + 1:), &
39,41d37
<     else
<       write (iw,'(/10x,a,/)') "To print Virtual Set as well, use keyword ""ALLVEC"""
<     end if
49c45
<    !  The value is multipled by 100, and printed as a percentage.
---
>    !  The value is multipled by 10,000, and printed as an integer.
54c50
<     use molkst_C, only: norbs, numat
---
>     use molkst_C, only: norbs
70,71c66,69
<     integer :: i, ii, iunsrt, j, jl, ju, k, kk, l, lj, loop, m, n, nj, ibig(100), jbig(100)
<     double precision :: const, sum, eig_min, xbig(100)
---
>     integer :: i, ii, iunsrt, j, jl, ju, k, kk, l, lj, loop, m, n, nj
>     double precision :: const, sum, eig_min
>     integer, dimension (100) :: ibig, jbig
>     double precision, dimension (100) :: xbig
74d71
<     character :: num_1*1, num_2*1
81c78,79
<     end if   
---
>     end if
>    
131,132d128
<     num_1 = char(ichar("3") +int(log10(numat + 0.05)))
<     num_2 = char(ichar("2") +int(log10(norbs + 0.05)))
153c149
<         if (sum < const*100.d0) exit
---
>         if (sum < const) exit
159,180c155,156
<       loop = loop - 1
<       sum = 0.d0
<       do j = 1, loop 
<         sum = sum + jbig(j)**2
<       end do
<       k = iunsrt + i_offset
<       sum = 1.d8/sum
<       if (loop == 1) then
<         if (jbig(1)*0.01d0> 99.949d0) then
<           write (iw, '(i'//num_1//',f10.4,f17.5, 3x,a2,i'//num_2//',f6.1)') k, sum,eigs(i), elemnt(nat(ibig(1))),ibig(1),jbig(1)*0.01d0 
<         else
<           write (iw, '(i'//num_1//',f10.4,f17.5, 3x,a2,i'//num_2//',f6.2)') k, sum,eigs(i), elemnt(nat(ibig(1))),ibig(1),jbig(1)*0.01d0
<         end if
<       else
<         if (loop < 6) then
<           write (iw, '(i'//num_1//',f10.4,f17.5, 4(5(3x,a2,i'//num_2//',f6.2)))') &
<           k, sum,eigs(i), (elemnt(nat(ibig(j))),ibig(j),jbig(j)*0.01d0, j=1, loop) 
<         else
<           write (iw, '(i'//num_1//',f10.4,f17.5, 4(5(3x,a2,i'//num_2//',f6.2),/,'//num_1//'x,27x))') &
<           k, sum,eigs(i), (elemnt(nat(ibig(j))),ibig(j),jbig(j)*0.01d0, j=1, loop) 
<         end if 
<       end if 
---
>       write (iw, "(I5,F9.4,50(5(I5,1X,A2,I5),/14X))") iunsrt + i_offset, eigs (i), &
>      & (ibig(j), elemnt(nat(ibig(j))), jbig(j), j=1, loop-1)
184,186c160
<   end subroutine prtlmn
<   
<   
---
> end subroutine prtlmn
diff ./react1.F90 ../../MOPAC/src/react1.F90
16d15
<       use to_screen_I
diff ./readmo.F90 ../../MOPAC/src/readmo.F90
348,373d347
<         if (index(keywrd, " INT") /= 0) then
<           call xyzint (coord, numat, na, nb, nc, 1.d0, geo) 
<           lopt(:,1) = 0
<           lopt(2:,2) = 0
<           lopt(3,3) = 0
<         end if
<         if (index(keywrd, " XYZ") /= 0) then
<           numat = 0 
<           do i = 1, natoms 
<             if (labels(i) /= 99) then 
<               numat = numat + 1 
<               labels(numat) = labels(i)
<               txtatm(numat) = txtatm(i)
<               lopt(:,numat) = lopt(:,i)
<               na(numat) = 0
<             endif 
<             geo(:,i) = coord(:,i) 
<           end do 
< !
< !   If everything is marked for optimization then unconditionally mark the first
< !   three atoms for optimization
< !
<           if (k >= 3*numat - 6) lopt(:,:min(3, numat)) = 1
<           natoms = numat
<         end if
<         
630c604
< #else
---
> #elif BITS64
632a607,608
> #else
>     Set pre-processor directive BITS32 or BITS64.  This line causes a deliberate compile-time error
1408,1412c1384
<       if (index(keywrd," OLDGEO") /= 0) call delete_ref_key("OLDGEO", len_trim("OLDGEO"), ' ', 1)
<       if (index(keywrd, " NOTXT") /= 0) then
<         maxtxt = 0
<         txtatm = " "
<       end if
---
>       if (index(keywrd," OLDGEO") /= 0) call delete_ref_key("OLDGEO", len_trim("OLDGEO"), ' ', 1) 
1581,1583d1552
< !
< ! Do NOT use "txt_to_atom_no" in the next block - the format must be in PDB
< !
1585,1587c1554,1556
< !
< ! Atom defined using Jmol format
< !
---
>   !
>   ! Atom defined using Jmol format
>   !
diff ./resolv.F90 ../../MOPAC/src/resolv.F90
1c1
<       subroutine resolv(c, cold, mdim, eig, nocc, size_of_LMO) 
---
>       subroutine resolv(c, cold, mdim, eig, nocc) 
4c4
<       use molkst_C, only : norbs, numat, keywrd
---
>       use molkst_C, only : norbs, numat
10c10
<       real(double) , intent(in) :: eig(nocc), size_of_LMO(nocc) 
---
>       real(double) , intent(in) :: eig(nocc) 
13c13
<       integer :: loop, j, k, nsec, i, ij, ii, jj, l, mo1, mo2, mo3, atom_a, atom_b
---
>       integer :: loop, j, k, nsec, i, ij, ii, jj, l, mo1, mo2, mo3, mo4 
17,20c17
<       real(double) :: thresh, sum1, sum, coi, coj, sum2, sum3, &
<         sqrt_2, sqrt_3, sqrt_23, sqrt_6
<       logical :: l_banana, l_rabbit, lone_pair, multiple
<       logical, allocatable :: used_MO(:)
---
>       real(double) :: thresh, half, suml, sumi, sum, coi, coj, sum1, sum2, sum3, sum4 
33,43c30,31
<       thresh = 0.05d0
<       lone_pair = .false.
<       l_banana = (index(keywrd, "BANANA") /= 0)
<       l_rabbit = (index(keywrd, "RABBIT") /= 0)
<       allocate(used_MO(norbs))
<       used_MO = .false.
<       sqrt_2 = sqrt(0.5d0)
<       sqrt_3 = sqrt(1/3.d0)
<       sqrt_23 = sqrt(2/3.d0)
<       sqrt_6 = sqrt(1/6.d0)
<       
---
>       thresh = 1.D-3 
>       half = 0.5D0 - thresh 
46c34
< !  Test the LMO to see if it is a potential candidate for degeneracy.
---
> !  Is the LMO a potential candidate for degeneracy?
48,51d35
< !  If the LMO is entirely on one atom (a lone pair) or
< !  if the LMO is over 30% on one atom and entirely on two atoms (a double or triple bond)
< !
<         if (used_MO(loop)) cycle
54c38
<           sum1 = 0.D0 
---
>           suml = 0.D0 
56c40
<             sum1 = sum1 + c(k,loop)**2 
---
>             suml = suml + c(k,loop)**2 
59,84c43
< !  Only LMOs that are near 100% on an atom (a lone pair) or at least 30% on one atom and entirely
< !  on two atoms (a bond) are potential candidates.
< !
<           if (sum1 > 1.d0 - thresh) then
<             lone_pair = .true.
<             atom_a = j
<             exit
<           else if (sum1 > 0.3d0) then
<             do l = j + 1, numat
<               sum2 = 0.D0 
<               do k = nfirst(l), nlast(l) 
<                 sum2 = sum2 + c(k,loop)**2 
<               end do 
<               if (sum1 + sum2 > 1.d0 - thresh) exit
<             end do
<             if (l <= numat) then
<               atom_a = j
<               atom_b = l
<               exit
<             end if
<           end if
<         end do 
<         if (j > numat) then
< !
< ! No atoms qualify as belonging to either a lone pair or to an atom in a diatomic bond
< ! so go on to the next LMO
---
> !  Only LMOs that are 50% or 100% on an atom are potential candidates.
86c45
<           continue
---
>           if (suml<=thresh .or. suml>=half) cycle  
88,94c47
<         end if
< !
< ! If a lone pair, then "atom_a" is the atom involved
< ! If a bond, then "atom_a" is the first atom, and "atom_b" is the second atom in the bond
< !        
<         nsec = 1 
<         idegen(nsec) = loop
---
>         end do 
98,118c51,69
<         do i = loop + 1, nocc
< !
< ! Check that LMO "i" has not already been used.
< !
<           if (used_MO(i)) cycle
< !
< ! Check that LMO "i" has roughly the same number of centers as LMO "loop".
< ! If it does not, then it is not a candidate for rabbit ears or banana bonds
< !
<           if (abs(size_of_LMO(i) - size_of_LMO(loop)) > 0.3d0) cycle
<           multiple = .false.
<           sum1 = 0.d0
<           do k = nfirst(atom_a), nlast(atom_a)
<               sum1 = sum1 + c(k,i)**2
<           end do
<           if (lone_pair) then 
<             multiple = (sum1 > 1.d0 - thresh)
<           else 
<             sum2 = 0.d0
<             do k = nfirst(atom_b), nlast(atom_b)
<                 sum2 = sum2 + c(k,i)**2
---
>         nsec = 1 
>         idegen(1) = loop 
>        loop1: do i = loop+1,nocc
>          !C
>          !C   First do a quick check.
>          !C
>          !            SUMI=0.D0
>          !            DO 30 K=NFIRST(L),NLAST(L)
>          !   30       SUMI=SUMI+C(K,I)**2
>          !            IF(ABS(SUML-SUMI) .GT. THRESH) GOTO 60
>          !C
>          !C   LMO 'I' is not disqualified.  Now do a complete check.
>          !C
>          do j = 1,numat
>             suml = 0.d0
>             sumi = 0.d0
>             do k = nfirst(j),nlast(j)
>                suml = suml + c(k,loop)**2
>                sumi = sumi + c(k,i)**2
120,128c71,79
<             multiple = (sum1 + sum2 > 1.d0 - thresh) 
<           end if
<           if (multiple) then
<             nsec = nsec + 1
<             idegen(nsec) = i
<             used_MO(i) = .true.
<           end if
<         end do 
<         if (nsec /= 1 .and. nsec < 4) then 
---
>             if (abs(suml-sumi) > thresh) cycle loop1
>          end do
>          !
>          !   LMO 'I' is similar to LMO LOOP
>          !
>          nsec = nsec + 1
>          idegen(nsec) = i
>       end do loop1
>         if (nsec /= 1) then 
169,177d119
<             if (lone_pair .and. l_rabbit .or. .not. lone_pair .and. l_banana) then
<               sum3 = sqrt(0.5d0)
<               do i = 1, norbs 
<                 sum1 = sum3*c(i,mo1) + sum3*c(i,mo2) 
<                 sum2 = sum3*c(i,mo1) - sum3*c(i,mo2) 
<                 c(i,mo1) = sum1 
<                 c(i,mo2) = sum2 
<               end do
<             end if              
190,200c132,150
<             if (lone_pair .and. l_rabbit .or. .not. lone_pair .and. l_banana) then
<               do i = 1, norbs 
<                 sum1 = sqrt_3*c(i,mo1) - sqrt_2*c(i,mo2) +  sqrt_6*c(i,mo3)
<                 sum2 = sqrt_3*c(i,mo1) + sqrt_2*c(i,mo2) +  sqrt_6*c(i,mo3)
<                 sum3 = sqrt_3*c(i,mo1)                   - sqrt_23*c(i,mo3)
<                 c(i,mo1) = sum1 
<                 c(i,mo2) = sum2 
<                 c(i,mo3) = sum3 
<               end do
<               continue
<             end if            
---
>           case (4)  
>             mo1 = idegen(1) 
>             mo2 = idegen(2) 
>             mo3 = idegen(3) 
>             mo4 = idegen(4) 
>             do i = 1, norbs 
>               sum1 = vec(1)*c(i,mo1) + vec(2)*c(i,mo2) + vec(3)*c(i,mo3) + vec(&
>                 4)*c(i,mo4) 
>               sum2 = vec(5)*c(i,mo1) + vec(6)*c(i,mo2) + vec(7)*c(i,mo3) + vec(&
>                 8)*c(i,mo4) 
>               sum3 = vec(9)*c(i,mo1) + vec(10)*c(i,mo2) + vec(11)*c(i,mo3) + &
>                 vec(12)*c(i,mo4) 
>               sum4 = vec(13)*c(i,mo1) + vec(14)*c(i,mo2) + vec(15)*c(i,mo3) + &
>                 vec(16)*c(i,mo4) 
>               c(i,mo1) = sum1 
>               c(i,mo2) = sum2 
>               c(i,mo3) = sum3 
>               c(i,mo4) = sum4 
>             end do 
Only in ../../MOPAC/src/: resolv_I.F90
diff ./run_mopac.F90 ../../MOPAC/src/run_mopac.F90
695c695
<         if (index(keywrd, " HTML") /= 0) call write_path_html(1)
---
>         if (index(keywrd, " HTML") /= 0) call write_path_html
843,848d842
<       inquire(unit = ilog, opened = opend, name = line)
<       if (opend) then
<         rewind (ilog)
<         read(ilog,'(a)', iostat=i)line
<         if (i == -1) close(ilog, status = 'delete', iostat=i)
<       end if
diff ./switch.F90 ../../MOPAC/src/switch.F90
43,44c43,44
<          zsn7_TS, zpn7_TS, zdn7_TS, f0sd7_TS, g2sd7_TS, alp7_TS, v_par7_TS, alpb_and_xfac_pm7_ts, &
<          gues7_ts1, gues7_ts2, gues7_ts3 
---
>          zsn7_TS, zpn7_TS, zdn7_TS, f0sd7_TS, g2sd7_TS, alp7_TS, gues7_TS1, gues7_TS2, gues7_TS3, &
>          alpb_and_xfac_pm7_ts
324d323
<           v_par = v_par7_TS
diff ./to_screen.F90 ../../MOPAC/src/to_screen.F90
57c57
<   line, nscf, time0, sz, ss2, no_pKa, title, jobnam, job_no
---
>   line, nscf, time0, sz, ss2, no_pKa, title, jobnam
97,98c97,98
<   character :: fmt8p4*5, fmt9p3*5, fmt10p1*5, fmt10p2*5, fmt10p3*5, fmt9p4*5, fmt10p4*5, fmtnnp4*5, fmt9p5*5, &
<   fmt13p5*5, fmt13p6*5, fmt7p4*5, irc_or_drc*1, num*1
---
>   character :: fmt8p4*5, fmt9p3*5, fmt10p1*5, fmt10p2*5, fmt10p3*5, fmt9p4*5, fmt10p4*5, fmt9p5*5, fmt13p5*5, fmt13p6*5, &
>   fmt7p4*5, irc_or_drc*1, num*1
459,462c459
<         read(fmt9p4,'(3x,i2)')i
<         j = max(int(log10(sum)),0)        
<         write(fmtnnp4,"(i2.2,'.',i2.2)")4 + j + i, i
<         write(hook,"(10f"//fmtnnp4//")") (grad(i), i=1,nvar)
---
>         write(hook,"(10f"//fmt9p4//")") (grad(i), i=1,nvar)
1196c1193
<     if (time0 > 1.d0 .and. job_no < 4) then
---
>     if (time0 > 1.d0) then
diff ./to_screen_C.F90 ../../MOPAC/src/to_screen_C.F90
33c33
<                ! Definition    Effective mass of vibrational frequencies
---
>                ! Definition    Effective mass of vibrational frequence
40,43d39
< force_const, & ! Type          Force constant
<                ! Definition    Force constant for of vibrational frequencies
<                ! Units         millidynes per Angstrom
<                !
diff ./write_trajectory.F90 ../../MOPAC/src/write_trajectory.F90
1,35c1
< subroutine write_trajectory(xyz, escf, ekin, rc_dipo, time, xtot, l_dipole)
< !
< ! Write a single point in a trajectory to a file of type <file>.xyz or <file>.pdb
< !
< !  If the type is <file>.xyz then the single point consists of:
< !
< !  A line containing the number of atoms in the system.
< !  A line containing the text "Profile." followed by the model number,  some more text ending in the character "="
< !    and a real datum, either the heat of formation or the dipole moment.
< !    The geometry in Cartesian coordinates
< !
< !  Example of a single point in such a file (6 lines):
< !     4 
< !Profile.   2 HEAT OF FORMATION =    -0.467 KCAL =    -1.955 KJ
< !    N        0.00000        0.00000       -0.00092
< !    H        0.97231        0.00000        0.00427
< !    H       -0.48616        0.84205        0.00427
< !    H       -0.48616       -0.84205        0.00427
< !
< !  If the type if <file>.pdb then the single point consists of:
< !
< !  A line containing the text "MODEL" followed by the model number.
< !  A PDB file giving a header line, the geometry, and an "END" line
< !  A A line containing the text "ENDMDL"
< !
< !  Example of a single point in such a file (8 lines)
< !MODEL      2
< !HEADER Heat of Formation =       2.677 Kcal/mol
< !HETATM    1  N   NH3 A   1       0.000   0.000   0.000  1.00 -0.83      PROT N 
< !HETATM    2 1H   NH3 A   1       0.920   0.000   0.000  1.00  0.28      PROT H 
< !HETATM    3 2H   NH3 A   1      -0.460   0.797   0.000  1.00  0.28      PROT H 
< !HETATM    4 3H   NH3 A   1      -0.460  -0.797  -0.000  1.00  0.28      PROT H 
< !END
< !ENDMDL
< !                                 
---
> subroutine write_trajectory(xyz, mode, charge, escf, ekin, time, xtot)
40d5
<   use to_screen_I
42c7
<   double precision, intent (in) :: escf, ekin, time, xtot, rc_dipo
---
>   double precision, optional :: escf, ekin, time, xtot
44,46c9,13
<   logical, intent (in) :: l_dipole
<   integer :: icalcn = 0, i, k, j, ipdb = 14, imodel = 0, npt, ixyz1
<   character :: num1*1, num2*1, num3*1
---
>   double precision, optional :: charge(numat)
>   integer, intent (in) :: mode
>   integer :: icalcn = 0, i, k, j, io_stat, ipdb = 14, imodel = 0, npdb, npt
>   character :: dummy_char*1, num1*1, num2*1, num3*1
>   character, allocatable :: store_path(:,:)*100, store_hofs(:)*100  
48c15
<   save :: icalcn, ipdb, imodel, npt, ixyz1
---
>   save :: icalcn, ipdb, imodel, npt
54,57d20
<     if (l_dipole) then
<       ixyz1 = ixyz + 1
<       open(unit=ixyz1, file=xyz_fn(:len_trim(xyz_fn) - 4)//" for dipole.xyz")
<     end if      
61a25,26
>   select case (mode)  
>   case (1)!  write out a trajectory
65,72c30,34
<   write(ixyz,"(i6,a)") nl_atoms," "
<   num1 = char(ichar("1") + int(log10(jloop*1.01)))
<   factor = abs(escf)
<   num2 = char(max(ichar("0"), ichar("0") + min(9, int(log10(factor)) - 1)))
<   num3 = char(max(ichar("0"), ichar("0") + min(9, int(log10(4.184d0*factor)) - 1))) 
<   npt = npt + 1
<   if (l_dipole) then
<     write(ixyz1,"(i6,a)") nl_atoms," "
---
>     write(ixyz,"(i6,a)") nl_atoms," "
>     num1 = char(ichar("1") + int(log10(jloop*1.01)))
>     factor = abs(escf)
>     num2 = char(max(ichar("0"), ichar("0") + min(9, int(log10(factor)) - 1)))
>     num3 = char(max(ichar("0"), ichar("0") + min(9, int(log10(4.184d0*factor)) - 1)))     
74,127c36,57
<     " DIPOLE =", rc_dipo, " DEBYE"
<      k = index(line, "DIPO")
<      write(ixyz1,'(a,i4,a)')line(:8), npt," "//trim(line(k:))
<   end if
<   write(line,'(a, i'//num1//', a, f1'//num2//'.3, a, f1'//num3//'.3, a)')"Profile.", jloop, &
<     " HEAT OF FORMATION =", escf, " KCAL =", escf*4.184d0, " KJ"
<   k = index(line, "HEAT") 
<   write(ixyz,'(a,i4,a)')line(:8), npt," "//trim(line(k:))
<   do i = 1, numat
<     if (l_atom(i)) then
<       if (l_dipole) write(ixyz1,"(3x,a2,3f15.5)")elemnt(nat(i)), (xyz(j,i),j=1,3)
<       write(ixyz,"(3x,a2,3f15.5)")elemnt(nat(i)), (xyz(j,i),j=1,3)
<     end if
<   end do
<   if (mod(jloop,10) == 0) then! write out every 10'th iteration.
<     if (time > 1.d-6) then
<       write (line, "(a7,i6,a8,f17.5,a8,f9.4,a7,f9.4,a7,f9.3)") " CYCLE:", jloop, &
<         & "  Pot.E:", escf, "  Kin.E:", ekin, "  Move:", xtot,"  Time:", Min(time,99999.999d0)
<       else    
<         write (line, "(a7,i6,a19,f17.5,a8,f9.4,a7,f9.4,a7,f9.3)") " CYCLE:", jloop, &
<     & "  Potential energy:", escf, " Diff.:", ekin, "  Move:", xtot
<     end if
<     call to_screen(line)
<   endif
<   if (index(keywrd, " PDBOUT") /= 0) then
<     imodel = imodel + 1
<     write(ipdb,'(a,i7)')"MODEL",imodel 
<     call pdbout(ipdb)
<     write(ipdb,'(a)')"ENDMDL"
<   end if
< end subroutine write_trajectory
< subroutine reverse_trajectory(mode)
< !
< ! Read in a trajectory that was created earlier in this run, and
< ! write it back out, in reverse order of points.
< !                                 
<   use molkst_C, only : step_num, jloop => itemp_1, line, nl_atoms, keywrd
<   use chanel_C, only : ixyz, xyz_fn
<   implicit none
<   integer, intent (in) :: mode
<   integer :: icalcn = 0, i, k, io_stat, ipdb = 14, imodel = 0, npdb, npt, ixyzn
<   character :: dummy_char*1, xyz_fnn*200
<   character, allocatable :: store_path(:,:)*100, store_hofs(:)*100  
<   save :: icalcn, ipdb, imodel, npt
<   if (icalcn /= step_num) then
<     do i = len_trim(xyz_fn), 1, -1
<       if (xyz_fn(i:i) == "/" .or. xyz_fn(i:i) == "\") exit
<     end do
<     if (mode == 1) then
<       ixyzn = ixyz
<       xyz_fnn = trim(xyz_fn)
<     else
<       ixyzn = ixyz + 1
<       xyz_fnn = xyz_fn(:len_trim(xyz_fn) - 4)//" for dipole.xyz"
---
>       " HEAT OF FORMATION =", escf, " KCAL =", escf*4.184d0, " KJ"
>     k = index(line, "HEAT")
>     npt = npt + 1
>     write(ixyz,'(a,i4,a)')line(:8), npt," "//trim(line(k:))
>     do i = 1, numat
>       if (l_atom(i)) write(ixyz,"(3x,a2,3f15.5)")elemnt(nat(i)), (xyz(j,i),j=1,3)
>     end do
>     if (mod(jloop,10) == 0) then! write out every 10'th iteration.
>       if (time > 1.d-6) then
>         write (line, "(a7,i6,a8,f17.5,a8,f9.4,a7,f9.4,a7,f9.3)") " CYCLE:", jloop, &
>          & "  Pot.E:", escf, "  Kin.E:", ekin, "  Move:", xtot,"  Time:", Min(time,99999.999d0)
>        else    
>           write (line, "(a7,i6,a19,f17.5,a8,f9.4,a7,f9.4,a7,f9.3)") " CYCLE:", jloop, &
>      & "  Potential energy:", escf, " Diff.:", ekin, "  Move:", xtot
>       end if
>       call to_screen(line)
>     endif
>     if (index(keywrd, " PDBOUT") /= 0) then
>       imodel = imodel + 1
>       write(ipdb,'(a,i7)')"MODEL",imodel 
>       call pdbout(ipdb)
>       write(ipdb,'(a)')"ENDMDL"
129,138c59,64
<     open(unit=ixyzn, file=xyz_fnn)
<     if (index(keywrd, " PDBOUT") /= 0) &
<       open(unit = ipdb, file = xyz_fnn(:len_trim(xyz_fnn) - 3)//"pdb")
<     if (mode == 1) icalcn = step_num
<   end if
<  
<   close (ixyzn)
<   open(ixyzn, file = xyz_fnn)
<   rewind(ixyzn)
<   allocate (store_path(nl_atoms, jloop), store_hofs(jloop))
---
>     if (charge(1) > -100.d0) return  
>     case (2)!  Reverse the path
>     close (ixyz)
>     open(ixyz, file = xyz_fn)
>     rewind(ixyz)
>     allocate (store_path(nl_atoms, jloop), store_hofs(jloop))
142,153c68,79
<   do i = 1, 100000
<     read(ixyzn,*, iostat=io_stat)dummy_char
<     if (dummy_char =="0" .and. i < 0) return  ! dummy use of dummy_char
<     read(ixyzn,'(a)', iostat=io_stat)line
<     if (io_stat /= 0) exit
<     store_hofs(i) = trim(line)
<     read(ixyzn,"(a)", iostat=io_stat) &
<       (store_path(k,i), k = 1, nl_atoms)
<   end do
<   close (ixyzn)
<   open(ixyzn, file = xyz_fnn)
<   rewind(ixyzn)
---
>     do i = 1, 100000
>       read(ixyz,*, iostat=io_stat)dummy_char
>       if (dummy_char =="0" .and. i < 0) return  ! dummy use of dummy_char
>       read(ixyz,'(a)', iostat=io_stat)line
>       if (io_stat /= 0) exit
>       store_hofs(i) = trim(line)
>       read(ixyz,"(a)", iostat=io_stat) &
>         (store_path(k,i), k = 1, nl_atoms)
>     end do
>     close (ixyz)
>     open(ixyz, file = xyz_fn)
>     rewind(ixyz)
157,167c83,93
<   jloop = i - 1
<   npt = 0
<   do i = jloop, 2, -1  ! Exclude the first point - it's common to both paths
<     write(ixyzn,"(i6,a)") nl_atoms," "
<     k = index(store_hofs(i), "HEAT") + index(line, "DIPO")
<     npt = npt + 1
<     write(ixyzn,'(a,i4,1x,a)')store_hofs(i)(:8), npt,trim(store_hofs(i)(k:))
<     do k = 1, nl_atoms
<       write(ixyzn,"(a)") trim(store_path(k,i))
<     end do
<   end do  
---
>     jloop = i - 1
>     npt = 0
>     do i = jloop, 2, -1  ! Exclude the first point - it's common to both paths
>       write(ixyz,"(i6,a)") nl_atoms," "
>       k = index(store_hofs(i), "HEAT")
>       npt = npt + 1
>       write(ixyz,'(a,i4,1x,a)')store_hofs(i)(:8), npt,trim(store_hofs(i)(k:))
>       do k = 1, nl_atoms
>         write(ixyz,"(a)") trim(store_path(k,i))
>       end do
>     end do  
171,174c97,100
<   if (index(keywrd, " PDBOUT") /= 0) then
<     deallocate (store_path)
<     open(unit = ipdb, file = xyz_fnn(:len_trim(xyz_fnn) - 3)//"pdb")
<     rewind (ipdb)
---
>     if (index(keywrd, " PDBOUT") /= 0) then
>       deallocate (store_path)
>       open(unit = ipdb, file = xyz_fn(:len_trim(xyz_fn) - 3)//"pdb")
>       rewind (ipdb)
178,193c104,119
<     do npdb = 0, 10000
<       read(ipdb,'(a)') line
<       if (line(:6) == "ENDMDL") exit
<     end do
<     allocate (store_path(npdb, jloop))
<     rewind (ipdb)
<     do i = 1, 100000
<       read(ipdb,*, iostat=io_stat)dummy_char
<       if (dummy_char =="0" .and. i < 0) return  ! dummy use of dummy_char
<       read(ipdb,"(a)", iostat=io_stat) &
<         (store_path(k,i), k = 1, npdb)
<       if (io_stat /= 0) exit
<     end do
<     close (ipdb)
<     open(unit = ipdb, file = xyz_fnn(:len_trim(xyz_fnn) - 3)//"pdb")
<     rewind(ipdb)
---
>       do npdb = 0, 10000
>         read(ipdb,'(a)') line
>         if (line(:6) == "ENDMDL") exit
>       end do
>       allocate (store_path(npdb, jloop))
>       rewind (ipdb)
>       do i = 1, 100000
>         read(ipdb,*, iostat=io_stat)dummy_char
>         if (dummy_char =="0" .and. i < 0) return  ! dummy use of dummy_char
>         read(ipdb,"(a)", iostat=io_stat) &
>           (store_path(k,i), k = 1, npdb)
>         if (io_stat /= 0) exit
>       end do
>       close (ipdb)
>       open(unit = ipdb, file = xyz_fn(:len_trim(xyz_fn) - 3)//"pdb")
>       rewind(ipdb)
197,208c123,135
<     imodel = 0
<     jloop = i - 1
<     do i = jloop, 2, -1! Exclude the first point - it's common to both paths
<       imodel = imodel + 1
<       write(ipdb,"(a,i6)") "MODEL ", imodel
<       do k = 1, npdb
<         write(ipdb,"(a)") trim(store_path(k,i))
<       end do
<     end do          
<   end if
<   deallocate (store_path) 
< end subroutine reverse_trajectory
---
>       imodel = 0
>       jloop = i - 1
>       do i = jloop, 2, -1! Exclude the first point - it's common to both paths
>         imodel = imodel + 1
>         write(ipdb,"(a,i6)") "MODEL ", imodel
>         do k = 1, npdb
>           write(ipdb,"(a)") trim(store_path(k,i))
>         end do
>       end do          
>     end if
>     deallocate (store_path)
>   end select   
> end subroutine write_trajectory
Only in ../../MOPAC/src/: write_trajectory_I.F90
diff ./writmo.F90 ../../MOPAC/src/writmo.F90
8,10c8,10
<       ijulian, jobnam, line, mers, uhf, &
<       gui, density, formula, mozyme, mpack, stress, &
<       site_no, sz, ss2, maxtxt, E_disp, E_hb, E_hh, &
---
>       ijulian, jobnam, method_am1, method_pm3, method_mndod, line, mers, uhf, &
>       method_pm6, method_rm1, gui, density, formula, mozyme, mpack, stress, &
>       site_no, method_pm7,  method_PM7_ts, sz, ss2, maxtxt, E_disp, E_hb, E_hh, &
12c12
<       hpress, nsp2_corr, Si_O_H_corr, sum_dihed, atheat, &
---
>       n_methods, methods, methods_keys, hpress, nsp2_corr, Si_O_H_corr, sum_dihed, atheat, &
58c58
<       flepo(18)*58, iter(2)*58, namfil*241, num*2
---
>       flepo(18)*58, iter(2)*58, namfil*241, num*1
175,176d174
<         distortion = 0.d0
<         rms = 0.d0
217,218c215,216
<       gnorm_norm =  gnorm/sqrt(1.0*numat) + 1.d-8
<       write(num, '(i2)')  max(0, Int(Log10( gnorm_norm))) + 7
---
>       gnorm_norm =  gnorm/sqrt(1.0*numat)
>       num = Char (min(2, max(0, Int(Log10( gnorm_norm))))+Ichar ("7"))
553c551
<             write(iw,"(10x,a,/)")"  LMOs being Re-Localized"
---
>             write(iw,"(a,/)")"  LMOs being Re-Localized"
555,558c553
< !
< !  Suppress re-localization of the virtual set.  Not of interest to users.
< !
< !            call local_for_MOZYME("VIRTUAL") 
---
>             call local_for_MOZYME("VIRTUAL")
838c833
<         if (index(keywrd,' LOCAL') + index(keywrd,' RABBIT') + index(keywrd,' BANANA') /= 0) then 
---
>         if (index(keywrd,' LOCAL') /= 0) then 
diff ./wrtkey.F90 ../../MOPAC/src/wrtkey.F90
88,92c88
<       end if  
<       if (index(keywrd, "BANANA") /= 0) &
<         call mopend("Keyword BANANA only works with keyword LOCAL, i.e. NOT with MOZYME")
<       if (index(keywrd, "RABBIT") /= 0) &
<         call mopend("Keyword RABBIT only works with keyword LOCAL, i.e. NOT with MOZYME")
---
>       end if                                               
353c349
<   if (myword(allkey, " BIRAD"))  write (iw, '(" *  BIRADICAL  - SYSTEM HAS TWO UNPAIRED ELECTRONS")')
---
>   if (myword(allkey, " BIRAD"))  write (iw, '(" *  BIRADICAL- SYSTEM HAS TWO UNPAIRED ELECTRONS")')
356d351
<   if (myword(allkey, " DIPO"))   write (iw, '(" *  DIPOLE     - PRINT DIPOLE INSTEAD OF ENERGY IN TRAJECTORIES")')
1125,1126d1119
<   if (myword(allkey, " BANANA")) write (iw,'(" *  BANANA     - MAKE LOCALIZED ORBITALS WITH BANANA BONDS")')
<   if (myword(allkey, " RABBIT")) write (iw,'(" *  RABBIT     - MAKE LOCALIZED ORBITALS WITH RABBIT EARS")')
1160a1154
>   character (len=20) :: spaces
1165a1160
>   spaces = " "
1331,1332c1326,1328
<     j = Index (keywrd(i:), ") ") + i 
<      if (j < i) then
---
>     j = Index (keywrd(i:), " ") + i 
>     j = Index (keywrd(i:j), ")") + i
>     if (j < i) then
1335,1349c1331,1333
<       j = Index (keywrd(i:), ") ") + i 
<       if (index(keywrd(i:j), '"') /= 0) &
<         write (iw, '(" *               ATOMS DEFINED AS BEING FULLY IONIC", /," *",15x,a)') keywrd(i + 8:j - 2)//" ="
<     end if
< !
< ! Convert PDB into atom-numbers
< !
<     do
<       k = index(keywrd(i:j), '"')
<       if (k == 0) exit
<       call txt_to_atom_no(keywrd(i:j), k, .false.)
<     end do
<     if (j > i) then
<       j = Index (keywrd(i:), ") ") + i 
<       write (iw, '(" *",15x,a)') keywrd(i + 8:j - 2)
---
>       ii = max(9 + i - j, 1)
>       write (iw, '(" *  ", a, "- ELEMENTS DEFINED AS BEING FULLY IONIZED METALS")') &
>       keywrd(i + 8:j + 9)//spaces(:ii)
